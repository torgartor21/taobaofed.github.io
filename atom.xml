<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Taobao FED | 淘宝前端团队]]></title>
  <subtitle><![CDATA[淘宝前端团队（FED）]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://taobaofed.org/"/>
  <updated>2015-11-13T05:20:11.000Z</updated>
  <id>http://taobaofed.org/</id>
  
  <author>
    <name><![CDATA[Taobao FED]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[在 iOS 模拟器中调试 Web 页面]]></title>
    <link href="http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/"/>
    <id>http://taobaofed.org/blog/2015/11/13/web-debug-in-ios/</id>
    <published>2015-11-13T03:31:07.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1Ml2nKpXXXXX0aXXXXXXXXXXX-900-500.png" alt="在 iOS 模拟器中调试 Web 页面"></p>
<p>双十一大家“买买买”了吗？我猜你们要么是躺在沙发上，要么是躲在被窝里用手机和 Pad 下的单，因为我就是这么干的。当然我也不是瞎猜，天猫官方微博公布的数据为证：无线端交易额占比一路保持在 70% 以上，最后定格在 68%（据说峰值数据更是丧心病狂，具体数据未公布，大家猜猜吧）。</p>
<p>“Mobile First” 真的已经不是喊喊口号而已！部分业务形态甚至直接 “Mobile Only” 了。当然所谓的 “Mobile” 绝不局限于 Native App，Web 页面仍是不可替代存在，我始终坚信不管是手机端还是其他终端 Web 模式依然代表着未来。</p>
<p>不过开发手机上的 Web 页面调试一直是一个老大难问题。 虽然 Chrome DevTools 可以模拟手机的环境，但与真实环境差别还是比较大的，另外 Chrome 模拟的环境对 App 内 Webview 场景也无能为力（手机淘宝上的无线 Web 页面有非常多的功能需要调用 Webview 提供的 JSBridge 接口实现）。所以真机调试和模拟器调试是无线 Web 开发必备技能。</p>
<p>真机相对复杂留到下次讲，今天我们先看看怎么在 iOS 模拟器里调试 Web 页面。</p>
<p>iOS 模拟器（iOS Simulator）是捆绑在 Xcode 里的，所以这篇文章的操作系统环境仅限 Mac OS，且已安装 Xcode。强烈建议大家从 App Store 下载 Xcode，理由你们都懂。</p>
<h2 id="启动_iOS_Simulator">启动 iOS Simulator</h2><p>常规的方式就是先启动 Xcode，再从 Xcode 菜单中启动模拟器。对于我们只是用模拟器来调试 Web 页面而言，每次都启动 Xcode 显然效率太低，是否可以跳过 Xcode 直接启动模拟器呢？</p>
<p>虽然模拟器捆绑在 Xcode 中，但是本身是一个单独的应用程序，安装路径在：</p>
<p><code>/Applications/Xcode.app/Contents/Developer/Applications/iOS Simulator.app</code></p>
<p>Tips：上面是 Xcode 6 中的应用名，Xcode 7 已改名为：Simulator.app，路径不变。</p>
<p>通过常规的方式启动模拟器后，发现 Dock 菜单上多出了一个模拟器的图标，这时即便退出 Xcode，模拟器任然能正常工作。为了方便下次开启模拟器，可以在 Dock 模拟器图标上右键选择：“在 Dock 中保留”，这样下次就可以通过直接点击图标启动了：</p>
<p><img src="https://img.alicdn.com/tps/TB14vfIKpXXXXanXXXXXXXXXXXX-748-321.png" alt=""></p>
<p>模拟器默认加载的是上次退出时使用的设备，需要更换的话到 “Hardware &gt; Device” 菜单下选择即可。</p>
<p><img src="https://img.alicdn.com/tps/TB1IKzrKpXXXXaqXFXXXXXXXXXX-683-688.png" alt=""></p>
<p>接下来就简单了，在模拟器中用 Safari 打开你要调试的页面，再打开 Mac 上的 Safari，在“开发 &gt; iOS Simulator”菜单下选中模拟器中打开的页面就可以调试了。如果没有“开发”菜单，请到“偏好设置 &gt; 高级”中开启。</p>
<p><img src="https://img.alicdn.com/tps/TB1UwfpKpXXXXcqXFXXXXXXXXXX-1121-616.png" alt=""></p>
<h2 id="在模拟器中安装_App">在模拟器中安装 App</h2><p>如果只是在手机上的 Safari 中调试页面，那么跟直接在 Mac 的 Safari 中并没有太大区别，完全没有必要花大力气在模拟器中搞。我们的最终目标是要调试 App Webview 中的 Web 页面，接下来我们看看怎么把 App 装到模拟器里，这里我们以手机淘宝 App 为例。</p>
<p>模拟器上是没有 App Store 的，也不能下载 ipa 文件安装。只能安装基于源代码打包出来的 App Bundle，为了演示我已经预先从手机淘宝的 App 开发那里获得了名为： taobao.app 的 App Bundle。</p>
<p>另外 Xcode 提供了一个 simctl 命令，可以对模拟器做各种操作。simctl 命令的路径是：</p>
<p><code>/Applications/Xcode.app/Contents/Developer/usr/bin/simctl</code></p>
<p>在终端执行命令：</p>
<p><code>/Applications/Xcode.app/Contents/Developer/usr/bin/simctl install booted taobao.app</code> </p>
<p><img src="https://img.alicdn.com/tps/TB1z6noKpXXXXaoXVXXXXXXXXXX-336-608.png" alt=""></p>
<p>就可以把手机淘宝安装在前面启动的模拟器中了（参数 booted 指的是当前启动的模拟器）。嫌每次执行 simctl 的路径太长，可以使用 xcrun 命令，它会自动查找并启动已注册的 Xcode 命令行开发工具，比如：<code>xcrun simctl xxx</code>。</p>
<p>App 安装好了，接下来我们让 App 打开我们要调试的页面，依旧还是使用 simctl 命令：</p>
<p><code>xcrun simctl openurl booted taobao://h5.m.taobao.com/guang/index.html</code></p>
<p>Tips：<code>taobao://</code> 是模拟器在安装 taobao.app 时注册的协议（scheme），当出现次协议的 URL 请求时默认会使用手机淘宝打开。不同的 App 在系统注册的协议各不相同，需要根据实际情况填写。如果需要在 Safari 中打开直接用 <code>http://</code> 协议头即可。</p>
<p>OK，成功在手机淘宝的 Webview 打开页面。后面怎么做就不用教了吧！在 Mac 上打开 Safari， “开发 &gt; iOS Simulator” 菜单下选中模拟器中打开的页面，看图：</p>
<p><img src="https://img.alicdn.com/tps/TB1Jn_vKpXXXXcUXpXXXXXXXXXX-1108-607.png" alt=""></p>
<p>Tips：simctl 更多功能可以执行 <code>xcrun simctl help</code> 命令查看。</p>
<h2 id="还有么有优化空间">还有么有优化空间</h2><p>在模拟器中安装 App，在 App 中打开 Web 页面都是在终端完成的，启动模拟器可不可以也在终端完成呢？答案是肯定的。</p>
<p>前面已经提到其实模拟器是一个独立的应用程序，所以我们可以通过 Mac 自带的 open 命令来运行，命令如下：<code>open -a &quot;iOS Simulator&quot;</code>。还可以在启动的时候指定模拟哪个设备：<code>open -a &quot;iOS Simulator&quot; --args -CurrentDeviceUDID &lt;udid&gt;</code>。udid 可以通过命令：<code>xcrun simctl list</code> 获得，执行后会列出当前已下载的设备列表，如图：</p>
<p><img src="https://img.alicdn.com/tps/TB1hh6iKpXXXXX0aXXXXXXXXXXX-806-299.png" alt=""></p>
<p>中间那串数字就是 udid，启动设备为 “iPhone 4S” 的 iOS 模拟器，命令应该是这样的：</p>
<p><code>open -a &quot;iOS Simulator.app&quot; --args -CurrentDeviceUDID &quot;FCE2CFE8-64C3-4DBE-906B-B9BF4180DE49&quot;</code></p>
<p>如果已升级到 Xcode 7 命令为：</p>
<p><code>open -a &quot;Simulator.app&quot; --args -CurrentDeviceUDID &quot;FCE2CFE8-64C3-4DBE-906B-B9BF4180DE49&quot;</code></p>
<p>至此，“启动模拟器”、“安装 App”、“打开 Web 页面” 我们都可以通过终端命令执行了。不过每次调试都要执行一遍这一点都不符合前端爱装 “X” 的个性。也许你想到了把这些命令封装到一个 shell 脚本中，如果这是这样的话也太小看我们装 “X” 的功力了。</p>
<p>现在不是“云”很火吗！我们也上个“云”。试想一下：所有的前端只要打开一个固定的网站，网站就会显示您当前系统支持启动哪些设备的 iOS 模拟器，只要在网站上轻轻一点本地的模拟器就启动起来了。不仅如此，网站还可以控制模拟器安装指定的 App，用指定的 App 打开的网页。像这样：</p>
<p><img src="https://img.alicdn.com/tps/TB1hY2pKpXXXXblXVXXXXXXXXXX-716-450.png" alt=""></p>
<p>这是淘宝前端团队内部系统：MDS（Mobile pages Develop &amp; Debug Solution）的一个局部界面（不知道大家有么有发现，文章写到这里，我的 Xcode 版本已经从 6 升级到了 7 ^ ^！吐槽下 App Store，真的很慢~~~）。</p>
<p>光有个网站就能启动本地的模拟器那是气功大师才干的出来的事儿，配合网站还需要一个安装在本地电脑的 SDK（npm）。为了启动个模拟器搞个网站又搞个 SDK？如果你是这么认为的，那是真的认为我们只是在装 “X” 了。MDS 要处理的事情远远比想象地要多，比如本地怎么才能获取最新的手机淘宝 App Bundle。 另外，MDS 还集成了一个云端的 DevTools 工具，这块内容下次有机会再细讲。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1Ml2nKpXXXXX0aXXXXXXXXXXX-900-500.png" alt="在 iOS 模拟器中调试 Web 页面"></p>
<p>双十一大家“买买买”了吗？我猜你们要么是躺在沙发上]]>
    </summary>
    
      <category term="debug" scheme="http://taobaofed.org/tags/debug/"/>
    
      <category term="iOS" scheme="http://taobaofed.org/tags/iOS/"/>
    
      <category term="mobile" scheme="http://taobaofed.org/tags/mobile/"/>
    
      <category term="工具&amp;平台" scheme="http://taobaofed.org/categories/%E5%B7%A5%E5%85%B7-%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML 压缩服务治理]]></title>
    <link href="http://taobaofed.org/blog/2015/11/12/html-minify-service/"/>
    <id>http://taobaofed.org/blog/2015/11/12/html-minify-service/</id>
    <published>2015-11-12T05:28:49.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img.alicdn.com/tps/TB1eBPqKpXXXXcwXXXXXXXXXXXX-900-500.jpg" alt="HTML 压缩服务治理"></p>
<h2 id="缘由">缘由</h2><p>笔者最近在研究如何实现页面 HTML 及内联 JS/CSS 的实时压缩功能。</p>
<p>首先笔者尝试了在前端模块中扫描内联的 JS/CSS 并压缩，这样还可以集成至前端模块的上传工具中。观察了一段时间发现这样无法处理模板中的 JS/CSS，造成很多遗漏的 JS/CSS 不能压缩。</p>
<p>于是笔者转而考虑对页面进行实时 HTML 压缩，这次考察了坑过许多 Node.js 开发者的 html-minifier 模块。该模块同时包含内联 JS/CSS 的压缩功能，功能是十分丰富的。不幸的是，很快笔者发现该模块应用在线上服务器环境极为不稳定，一场 HTML 压缩服务治理的探索就这样开始了。</p>
<h2 id="CPU_100%">CPU 100%</h2><p>笔者先对少量页面进行了 HTML 及内联 JS/CSS 压缩测试，发现效果还不错。随后开始寻找更多页面样板进行尝试，很快遇到了第一个坑，“html-minifier 压缩部分 HTML 片段会导致 CPU 100%”。</p>
<p>案例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 html-minifier 压缩导致 CPU 100% 案例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"background:url(\"</span><span class="value">FyueIVXXXXanapXXSutbFXXX.jpg\")</span> <span class="attribute">no-repeat</span>"&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很明显，案例中有 HTML 语法错误，而 html-minifier 依赖 HTML 语法树的解析，对不合理的输入未做异常处理导致 CPU 100%。恰恰这样的语法错误是前端用户经常不小心写出来的，所以笔者不能无视。提 Issue 给模块作者，得到的回复是 html-minifier 不能处理非法 HTML，没有改进计划。</p>
<p>这里笔者评估自己没精力独立修复此问题，因此想到了一个绕开此问题的办法，使用 vm 模块在独立的上下文处理压缩任务，并设置超时时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="keyword">let</span> sandbox = &#123;</span><br><span class="line">  minify: minify,</span><br><span class="line">  config: config.minify,</span><br><span class="line">  src: body</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  vm.runInNewContext(<span class="string">'try&#123;result=minify(src,config)&#125;catch(e)&#123;err=e&#125;'</span>, sandbox, &#123;</span><br><span class="line">    timeout: config.minifyTimeout</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// ScriptTimeout 异常，根本原因包含真超时和内联 HTML/CSS 压缩异常</span></span><br><span class="line">  debug(<span class="string">'html minify timeout.'</span>);</span><br><span class="line">  <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试该方案有效，vm 在指定的时间内完不成任务会抛出 ScriptTimeout 异常，再也不会直接导致 CPU 100% 了。</p>
<p>Node.js 的 vm 模块提供了一个独立的 JS 执行上下文，但并不是独立的进程，因此它并不是进程安全的。这里笔者只用来避免 JS 上下文里的 CPU 100%，vm 完全可以胜任。</p>
<p>要了解更多 vm 模块知识可以参考官方文档：<a href="https://nodejs.org/api/vm.html" target="_blank" rel="external">https://nodejs.org/api/vm.html</a></p>
<h2 id="不标准的异常信息">不标准的异常信息</h2><p>html-minifier 奇葩的是，遇到不标准 HTML 并非都会 CPU 100%，部分案例还是可以抛出异常的。比如下面这种：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>hi\n<span class="comment">&lt;!--</span></span><br></pre></td></tr></table></figure>
<p>此时，html-minifier 抛出一个 Parse Error 的“异常”，但是这个异常是字符串对象，而不是 Error 对象。如果你需要对 Error 对象做分类处理或其它包装，需要注意这个问题。</p>
<h2 id="速度慢">速度慢</h2><p>测试发现，页面的 HTML 压缩会花费 300-500ms，而页面的渲染时间一般在 100ms 以内。如此低的性能在实时渲染性能要求较高的应用中是不可接受的。</p>
<p>因此笔者为了追求更快的压缩速度，尝试了如下优化方法：</p>
<ul>
<li>舍弃部分不是不太关键的功能。比如页面的内联 CSS 很少，就可以关闭内联 CSS 的压缩功能。经测试，移除内联 CSS 压缩可以节省 100ms 的时间。</li>
<li>内存管理优化，更少的 GC 是高效压缩的保障。观察发现在遇到 Node.js 进行大量内存回收时，HTML 压缩时间会变成平常的 4-5 倍。内存问题笔者在 Node.js 0.12.x/4.x 都有遇到，一旦出现问题，会对稳定性及性能产生很大影响。</li>
</ul>
<h2 id="总结">总结</h2><p>在优化 HTML 压缩的过程中，笔者解决了稳定性问题，但是没有从根本上解决性能问题。后续会考察最近新发现的 minimize 模块，该模块号称适合集成至线上服务器环境，因此比较重视压缩性能。缺点是该模块还在快速发展中，截止到截稿时，其 JS 压缩插件还未发布。</p>
<p>总结本文的目的，主要是抛砖引玉——我们正在研究实现一个高效稳定的 HTML 压缩模块，加入我们，一起来完善 Node.js 开发体系的基础设施吧。</p>
<p>Node.js 应用还在快速发展，我们遇到的问题也越来越有挑战。如果你有兴趣挑战，快点击<a href="https://job.alibaba.com/zhaopin/position_detail.htm?positionId=20925" target="_blank" rel="external">加入我们</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img.alicdn.com/tps/TB1eBPqKpXXXXcwXXXXXXXXXXXX-900-500.jpg" alt="HTML 压缩服务治理"></p>
<h2 id="缘由">缘由</h2><p>笔者最近在研究如何实现页面 H]]>
    </summary>
    
      <category term="HTML 压缩" scheme="http://taobaofed.org/tags/HTML-%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动端开发小记 - Flexbox]]></title>
    <link href="http://taobaofed.org/blog/2015/11/11/flexbox-in-mobile-web/"/>
    <id>http://taobaofed.org/blog/2015/11/11/flexbox-in-mobile-web/</id>
    <published>2015-11-11T02:38:03.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1i_5SKpXXXXczXFXXXXXXXXXX-900-500.jpg" alt="移动端开发小记 - Flexbox"></p>
<p>在开发移动端页面的时候，出去布局方便和减少代码量的考虑，使用了 Flexbox 的布局方式，在其中也遇到了一些问题，简单记录下。</p>
<h2 id="什么是_Flexbox">什么是 Flexbox</h2><p>说到 Flexbox，大家应该都不陌生，网络上也有 N 多的教程。但是在这里还是简单说一下，就当回顾知识了吧。</p>
<p>CSS 2.1 定义了四种布局模式 ― 由一个盒与其兄弟、祖先盒的关系决定其尺寸与位置的算法：</p>
<ul>
<li>块布局 ― 为了呈现文档而设计出来的布局模式；</li>
<li>行内布局 ― 为了呈现文本而设计出来的布局模式；</li>
<li>表格布局 ― 为了用格子呈现 2D 数据而设计出来的布局模式；</li>
<li>定位布局 ― 为了非常直接地定位元素而设计出来的布局模式，定位元素基本与其他元素毫无关。</li>
</ul>
<p>而 Flexbox（伸缩布局）是为了呈现复杂的应用与页面而设计出来的，一种更加方便有效，能够在未知或者动态尺寸的情况下自由分配容器空间的布局方式。</p>
<p>要说明 Flexbox 的布局模型，就必须要放规范上的这张图：</p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/386a363208b3d74b243ca878fc571133a30eddef" alt="flexbox"></p>
<ul>
<li><span style="color:hsl( 0,80%,40%);">main axis（主轴）</span><ul>
<li><span style="color:hsl( 0,80%,40%);">main dimension（主轴方向）</span></li>
<li>The main axis of a flex container is the primary axis along which flex items are laid out. It extends in the main dimension.</li>
<li>主轴是伸缩项目在伸缩容器里分布所遵循的主要轴线，在主轴方向上延伸。</li>
</ul>
</li>
<li><span style="color:hsl(240,80%,50%)">main-start（主轴起点）</span><ul>
<li><span style="color:hsl(240,80%,50%)">main-end（主轴终点）</span></li>
<li>The flex items are placed within the container starting on the main-start side and going toward the main-end side.</li>
<li>伸缩项目从容器的主轴起点开始放置，直到主轴终点。</li>
</ul>
</li>
<li><span style="color:hsl(120,80%,30%);">main size（主轴尺寸）</span><ul>
<li><span style="color:hsl(120,80%,30%);">main size property（主轴尺寸属性）</span></li>
<li>A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the width or height property, whichever is in the main dimension.</li>
<li>伸缩项目在主轴方向上的长或者宽是这个项目的主轴尺寸。一个伸缩项目的主轴属性是在主轴方向上的长或者宽属性。</li>
</ul>
</li>
<li><span style="color:hsl( 0,80%,40%);">cross axis（侧轴）</span><ul>
<li><span style="color:hsl( 0,80%,40%);">cross dimension（侧轴方向）</span></li>
<li>The axis perpendicular to the main axis is called the cross axis. It extends in the cross dimension.</li>
<li>和主轴垂直的轴叫做侧轴，它在侧轴方向上延伸。</li>
</ul>
</li>
<li><span style="color:hsl(240,80%,50%)">cross-start（侧轴起点）</span><ul>
<li><span style="color:hsl(240,80%,50%)">cross-end（侧轴终点）</span></li>
<li>Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.</li>
<li>包含伸缩元素的伸缩行从容器的侧轴起点开始放置，直到侧轴终点。</li>
</ul>
</li>
<li><span style="color:hsl(120,80%,30%);">cross size（侧轴尺寸）</span><ul>
<li><span style="color:hsl(120,80%,30%);">cross size property（侧轴尺寸属性）</span></li>
<li>The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of width or height that is in the cross dimension.</li>
<li>伸缩项目在侧轴方向上的长或者宽是它的侧轴尺寸。侧轴尺寸属性则是在侧轴方向上的长或者宽属性。</li>
</ul>
</li>
</ul>
<h2 id="使用_Flexbox">使用 Flexbox</h2><p>现在大部分的主流浏览器都已经支持了 Flexbox 或者它的旧版语法。如果是使用在移动端，基本上是都支持的。为了兼容新老版本的语法，可以这样使用（ Less ）:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父元素</span></span><br><span class="line"><span class="class">.flex-box</span>() &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -moz-box;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子元素</span></span><br><span class="line"><span class="class">.flex</span>(<span class="variable">@v</span>) &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-flex</span>: <span class="variable">@v</span>;</span><br><span class="line">  <span class="attribute">-moz-box-flex</span>:  <span class="variable">@v</span>;</span><br><span class="line">  <span class="attribute">-webkit-flex</span>:  <span class="variable">@v</span>;</span><br><span class="line">  <span class="attribute">-ms-flex</span>:  <span class="variable">@v</span>;</span><br><span class="line">  <span class="attribute">flex</span>:  <span class="variable">@v</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为子元素设置了 <code>flex: 1</code>，这样容器里面的子元素可以均分容器的空间。当然，可以为某个子元素指定一个宽度，这样剩下的子元素就会平分剩下的空间。</p>
<p>如下图中的品牌墙：</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/ba4f93393cd10d039621c16ec365d710a357b73f" alt="brand_logo"></p>
<h2 id="flex-basis">flex-basis</h2><p>这个属性，还是要稍微说一说的。这个属性是新版规范里面提到的属性。它用来描述伸缩元素（ flex-item ）的初始主轴尺寸和基准值，也就是在根据伸缩比率计算剩余空间分布之前的尺寸值，如果在 <code>flex</code> 中省略了这个值，则默认值是 <code>0</code> ， <strong>注意没有单位</strong> 。它的另一个取值是 <code>auto</code> ，这个时候，元素的初始主轴长度和基准值就是它本身的主轴长度，即取决于本身的内容长度。</p>
<p>两个取值的区别如下图：</p>
<p><img src="http://www.w3.org/TR/css3-flexbox/images/rel-vs-abs-flex.svg" alt="flex-basis"></p>
<p>看图更容易理解一些：值为 <code>0</code> 时，元素分配的是容器的空间。而当值为 <code>auto</code> 时，它分配的是减去元素内容之后剩余的容器空间。</p>
<p>在值为 <code>auto</code> 时，它的表现跟老版 Flex 规范的伸缩比例表现是一致的，如果盒子内容大小不一致，则每个盒子最后分配的空间大小也不一致。</p>
<p>所以，在处理这个显示异常时，要在元素上加一个 <code>width: 0%;</code> 来使其表现的正常。实际上，<code>flex-basis: 0;</code> 的行为就是为元素加上一个类似 <code>width: 0%;</code> 的属性，来分配容器空间。</p>
<p>Flexbox 这个模块有很多的属性，这里只介绍最基本的使用，更多内容详见<a href="http://www.w3.org/TR/css3-flexbox/#flexibility" target="_blank" rel="external">规范</a>或者 Google。</p>
<h2 id="需要注意的点">需要注意的点</h2><ul>
<li>低版本安卓下大多用的是老版本的规范，所以会导致一些问题：<ul>
<li>在使用比例伸缩时会因为盒子内容大小不等导致内容无法等分的问题，这个时候可以为这个元素添加 <code>width: 0%;</code> 将其原始大小设为 0（比如 UC 浏览器，魅族 MX4，三星 N7100）；</li>
<li>旧版要求伸缩元素（ flex-item ）必须是块级元素，所以 inline 元素需要设置 <code>display: block;</code> 才可以正常显示。有部分国产手机的浏览器上就是这样的（比如：Vivo X3SW）；</li>
<li>Flex item 里面如果有一个块元素，设置了 margin-top，会出现溢出的问题，表现就是 margin 无效。需要在这个元素上添加 <code>overflow:hidden;</code> 来使其正常显示。</li>
</ul>
</li>
<li>因为 Flexbox 有新版和旧版规范，新版的有些属性（比如：<code>flex-wrap</code>），老版规范下并不支持，出于兼容性，最好避免使用；</li>
<li><code>text-overflow: ellipsis;</code> 在 <code>display: flex;</code> 元素上是没有效果的。</li>
</ul>
<h2 id="By_the_way">By the way</h2><p>还有一个有用的 CSS 属性，在移动端已经基本支持了，就是 <code>box-sizing: border-box;</code>。它在使用 <code>padding</code> 时非常有用，可以避免 <code>width</code> ，<code>padding</code> 的计算。可以这样子用：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box-sizing</span>(<span class="variable">@v</span>) &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: <span class="variable">@v</span>;</span><br><span class="line">  <span class="attribute">-moz-box-sizing</span>: <span class="variable">@v</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: <span class="variable">@v</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，要注意，在这种盒模型下，边框的宽度也会算在宽度里。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1i_5SKpXXXXczXFXXXXXXXXXX-900-500.jpg" alt="移动端开发小记 - Flexbox"></p>
<p>在开发移动端页面的时候，出去布局方便和减少代码量的考虑]]>
    </summary>
    
      <category term="Flexbox" scheme="http://taobaofed.org/tags/Flexbox/"/>
    
      <category term="mobile" scheme="http://taobaofed.org/tags/mobile/"/>
    
      <category term="web" scheme="http://taobaofed.org/tags/web/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[当我们谈论 cluster 时我们在谈论什么(下)]]></title>
    <link href="http://taobaofed.org/blog/2015/11/10/nodejs-cluster-2/"/>
    <id>http://taobaofed.org/blog/2015/11/10/nodejs-cluster-2/</id>
    <published>2015-11-10T03:27:12.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB17WhrKpXXXXXiXpXX2AXZ8pXX-900-500.png" alt="当我们谈论 cluster 时我们在谈论什么(下)"></p>
<p><a href="http://taobaofed.org/blog/2015/11/03/nodejs-cluster/">上篇文章</a>讲解了 Node.js 中多进程部署时遇到的各种问题，那么实际的线上项目中到底是如何利用多进程，如何保障各个 worker 进程稳定性的呢，又是如何利用 cluster 模块 fork 子进程，父子进程间又是如何实现通信的呢？本篇就来一一揭晓。</p>
<h2 id="负载均衡">负载均衡</h2><p>回忆一下上篇中提到的最初 Node.js 多进程模型，多个进程绑定同一端口，相互竞争 accpet 新到来的连接。由于无法控制一个新的连接由哪个进程来处理，导致各 worker 进程之间的负载非常不均衡。</p>
<p>于是后面就出现了基于 round-robin 算法的另一种模型。主要思路是 master 进程创建 socket，绑定地址以及端口后再进行监听。该 socket 的 fd 不传递到各个 worker 进程。当 master 进程获取到新的连接时，再决定将 accept 到的客户端连接分发给指定的 worker 处理。这里使用了<strong>指定</strong>, 所以如何传递以及传递给哪个 worker 完全是可控的。round-robin 只是其中的某种算法而已，当然可以换成其他的。</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1kT6gKpXXXXbyXXXXvNGU0VXX-533-352.png" alt="负载均衡"></p>
<p>同样基于这种模型也给出一个简单的 demo。</p>
<p>master 进程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">   workers.push(fork(<span class="string">'./worker'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handle = net._createServerHandle(<span class="string">'0.0.0.0'</span>, <span class="number">3000</span>);</span><br><span class="line">handle.listen();</span><br><span class="line">handle.onconnection = <span class="function"><span class="keyword">function</span> (<span class="params">err,handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> worker = workers.pop();</span><br><span class="line">    worker.send(&#123;&#125;,handle);</span><br><span class="line">    workers.unshift(worker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>woker 进程<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, handle</span>) </span>&#123;</span><br><span class="line">  start(handle);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="string">'hello Node.js'</span>;</span><br><span class="line"><span class="keyword">var</span> res = [<span class="string">'HTTP/1.1 200 OK'</span>,<span class="string">'content-length:'</span>+buf.length].join(<span class="string">'\r\n'</span>)+<span class="string">'\r\n\r\n'</span>+buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">handle</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'got a connection on worker, pid = %d'</span>, process.pid);</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> net.Socket(&#123;</span><br><span class="line">        handle: handle</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.readable = socket.writable = <span class="literal">true</span>;</span><br><span class="line">    socket.end(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于只有 master 进程接收客户端连接，并且能够按照特定的算法进行分发， 很好的解决了上篇中提到的由于竞争导致各 worker 进程负载不均衡的硬伤。</p>
<h2 id="优雅退出">优雅退出</h2><p>上篇文章开头提到 Node.js 被吐槽稳定性差，进程发生未捕获到的异常就会退出。实际项目中由于各种原因，不可避免最后上线时还是存在各种 bug 以及异常，最终进程退出。</p>
<p>当进程异常退出时，有可能该进程上还有很多未处理完的请求，简单粗暴的使进程直接退出必然导致所有的请求都会丢失，给用户带来非常糟的体验，这就非常需要一个进程优雅退出的方案。</p>
<p>给 process 对象添加 uncaughtException 事件绑定能够避免发生异常时进程直接退出。在回调函数里调用当前运行 server 对象的 close 方法，停止接收新的连接。同时告知 master 进程该 worker 进程即将退出，可以 fork 新的 worker 了。</p>
<p>接着在几秒中之后差不多所有请求都已经处理完毕后，该进程主动退出，其中 timeout 可以根据实际业务场景进行设置。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout<span class="list">(<span class="keyword">function</span> <span class="list">()</span> &#123;</span><br><span class="line">  process.exit<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;, timeout)</span></span><br></pre></td></tr></table></figure>
<p>这里面有一个小的细节处理，在关闭服务器之前，后续新接收的 request 全部关闭 keep-alive 特性，通知客户端不需要与该服务器保持 socket 连接了。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>&#123;</span><br><span class="line">    req.shouldKeepAlive = <span class="literal">false</span>;</span><br><span class="line">    res.shouldKeepAlive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!res._header) &#123;</span><br><span class="line">        res.setHeader(<span class="string">'Connection'</span>, <span class="string">'close'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第三方 <code>graceful</code> 模块专门来处理这种场景的，感兴趣的同学可以阅读下源码。</p>
<h2 id="进程守护">进程守护</h2><p>master 进程除了负责接收新的连接，分发给各 worker 进程处理之外，还得像天使一样默默地守护着这些 worker 进程，保障整个应用的稳定性。一旦某个 worker 进程异常退出就 fork 一个新的子进程顶替上去。</p>
<p>这一切 cluster 模块都已经好处理了，当某个 worker 进程发生异常退出或者与 master 进程失去联系（disconnected）时，master 进程都会收到相应的事件通知。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cluster.<span class="keyword">on</span>(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">&#123;</span><br><span class="line">    clsuter.fork();</span><br><span class="line">&#125;</span>);</span></span><br><span class="line"></span><br><span class="line">cluster.<span class="keyword">on</span>(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">&#123;</span><br><span class="line">    clsuter.fork();</span><br><span class="line">&#125;</span>);</span></span><br></pre></td></tr></table></figure>
<p>推荐使用第三方模块 recluster 和 cfork，已经处理的很成熟了。</p>
<p>这样一来整个应用的稳定性重任就落在 master 进程上了，所以一定不要给 master 太多其它的任务，百分百保证它的健壮性，一旦 master 进程挂掉你的应用也就玩完了。</p>
<h2 id="IPC">IPC</h2><p>master 进程能够接收连接进行分发，同时守护 worker 进程，这一切都离不开进程间的通信。<br>讲了这么多，终于到最核心的地方了，要用多进程模型就一定会涉及到 IPC（进程间通信）了。Node.js 中 IPC 都是在父子进程之间进行，按有无发送 fd 分为 2 种方式。</p>
<h3 id="发送_fd">发送 fd</h3><p>当进程间需要发生文件描述符 fd 时，libuv 底层采用消息队列来实现 IPC。master 进程接收到客户端连接分发给 worker 进程处理时就用到了进程间 fd 的传递。</p>
<h3 id="不发送_fd">不发送 fd</h3><p>这种情况父子进程之间只是发送简单的字符串，并且它们之间的通信是双向的。master 与 worker 间的消息传递便是这种方式。虽然 pipe 能够满足父子进程间的消息传递，但由于 pipe 是半双工的，也就是说必须得创建 2 个 pipe 才可以实现双向的通信，这无疑使得程序逻辑更复杂。</p>
<p>libuv 底层采用 socketpair 来实现全双工的进程通信，父进程 fork 子进程之前会调用 socketpair 创建 2 个 fd，下面是一个最简单的也最原始的利用 socketpair 来实现父子进程间双向通信的 demo。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BUF_SIZE <span class="number">100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> w,r;</span><br><span class="line">    <span class="keyword">char</span> * buf = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(<span class="number">1</span> , BUF_SIZE);</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX,SOCK_STREAM,<span class="number">0</span>,s) == -<span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create unnamed socket pair failed:%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent process's pid is %d\n"</span>,getpid());</span><br><span class="line">        close(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> *messageToChild = <span class="string">"a message to child  process!"</span>;</span><br><span class="line">        <span class="keyword">if</span> ((w = write(s[<span class="number">0</span>] , messageToChild , <span class="built_in">strlen</span>(messageToChild) ) ) == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Write socket error:%s\n"</span>,strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (r = read(s[<span class="number">0</span>], buf , BUF_SIZE )) == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Pid %d read from socket error:%s\n"</span>,getpid() , strerror(errno) );</span><br><span class="line">          <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Pid %d read string : %s \n"</span>,getpid(),buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Fork child process successed\n"</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Child process's pid is :%d\n"</span>,getpid());</span><br><span class="line">         close(s[<span class="number">0</span>]);</span><br><span class="line">         <span class="keyword">char</span> *messageToParent = <span class="string">"a message to parent process!"</span>;</span><br><span class="line">         <span class="keyword">if</span> ((w = write(s[<span class="number">1</span>] , messageToParent , <span class="built_in">strlen</span>(messageToParent))) == -<span class="number">1</span> ) &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"Write socket error:%s\n"</span>,strerror(errno));</span><br><span class="line">             <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">if</span> ((r = read(s[<span class="number">1</span>], buf , BUF_SIZE )) == -<span class="number">1</span>) &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"Pid %d read from socket error:%s\n"</span>, getpid() , strerror(errno) );</span><br><span class="line">             <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"Pid %d read string : %s \n"</span>,getpid(),buf); </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork failed:%s\n"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存为 socketpair.c 后运行 <code>gcc  socketpair.c -o socket &amp;&amp; ./socket</code> 输出</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent <span class="keyword">process</span><span class="attribute">'s</span> pid <span class="keyword">is</span> <span class="number">52853</span></span><br><span class="line">Fork child <span class="keyword">process</span> successed</span><br><span class="line">Child <span class="keyword">process</span><span class="attribute">'s</span> pid <span class="keyword">is</span> :<span class="number">52854</span></span><br><span class="line">Pid <span class="number">52854</span> read <span class="typename">string</span> : a message <span class="keyword">to</span> child  <span class="keyword">process</span>! </span><br><span class="line">Pid <span class="number">52853</span> read <span class="typename">string</span> : a message <span class="keyword">to</span> parent <span class="keyword">process</span>!</span><br></pre></td></tr></table></figure>
<h3 id="Node-js_中的_IPC">Node.js 中的 IPC</h3><p>上面从 libuv 底层方面讲解了父子进程间双向通信的原理，在上层 Node.js 中又是如何实现的呢，让我们来一探究竟。</p>
<p>Node.js 中父进程调用 fork 产生子进程时，会事先构造一个 pipe 用于进程通信，</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> process.binding(<span class="string">'pipe_wrap'</span>).Pipe(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>构造出的 pipe 最初还是关闭的状态，或者说底层还并没有创建一个真实的 pipe，直至调用到 libuv 底层的<code>uv_spawn</code>, 利用 socketpair 创建的全双工通信管道绑定到最初 Node.js 层创建的 pipe 上。</p>
<p>管道此时已经真实的存在了，父进程保留对一端的操作，通过环境变量将管道的另一端文件描述符 fd 传递到子进程。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">options</span>.envPairs.<span class="keyword">push</span>(<span class="string">'NODE_CHANNEL_FD='</span> + ipcFd);</span><br></pre></td></tr></table></figure>
<p>子进程启动后通过环境变量拿到 fd</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fd = <span class="built_in">parseInt</span>(process.env.NODE_CHANNEL_FD, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>并将 fd 绑定到一个新构造的 pipe 上</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> p</span> = new Pipe(<span class="literal">true</span>);</span><br><span class="line">p.<span class="keyword">open</span>(fd);</span><br></pre></td></tr></table></figure>
<p>于是父子进程间用于双向通信的所有基础设施都已经准备好了。说了这么多可能还是不太明白吧？ 没关系，我们还是来写一个简单的 demo 感受下。</p>
<p>Node.js 构造出的 pipe 被存储在进程的<code>_channel</code>属性上</p>
<p>master.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WriteWrap = process.binding(<span class="string">'stream_wrap'</span>).WriteWrap;</span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker = cp.fork(__dirname + <span class="string">'/worker.js'</span>);</span><br><span class="line"><span class="keyword">var</span> channel = worker._channel;</span><br><span class="line"></span><br><span class="line">channel.onread = <span class="function"><span class="keyword">function</span> (<span class="params">len, buf, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(buf.toString())</span><br><span class="line">        channel.close()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        channel.close()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'channel closed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = &#123; hello: <span class="string">'worker'</span>,  pid: process.pid &#125;;</span><br><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> WriteWrap();</span><br><span class="line"><span class="keyword">var</span> string = <span class="built_in">JSON</span>.stringify(message) + <span class="string">'\n'</span>;</span><br><span class="line">channel.writeUtf8String(req, string, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>worker.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WriteWrap = process.binding(<span class="string">'stream_wrap'</span>).WriteWrap;</span><br><span class="line"><span class="keyword">const</span> channel = process._channel;</span><br><span class="line"></span><br><span class="line">channel.ref();</span><br><span class="line">channel.onread = <span class="function"><span class="keyword">function</span> (<span class="params">len, buf, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(buf.toString())</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        process._channel.close()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'channel closed'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = &#123; hello: <span class="string">'master'</span>,  pid: process.pid &#125;;</span><br><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> WriteWrap();</span><br><span class="line"><span class="keyword">var</span> string = <span class="built_in">JSON</span>.stringify(message) + <span class="string">'\n'</span>;</span><br><span class="line">channel.writeUtf8String(req, string, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>运行<code>node master.js</code> 输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"hello"</span>:<span class="string">"worker"</span>,<span class="string">"pid"</span>:<span class="number">58731</span>&#125;</span><br><span class="line">&#123;<span class="string">"hello"</span>:<span class="string">"master"</span>,<span class="string">"pid"</span>:<span class="number">58732</span>&#125;</span><br><span class="line">channel closed</span><br></pre></td></tr></table></figure>
<h3 id="进程失联">进程失联</h3><p>在多进程服务器中，为了保障整个 web 应用的稳定性，master 进程需要监控 worker 进程的 exit 以及 disconnect 事件，收到相应事件通知后重启 worker 进程。</p>
<p>exit 事件不用说，disconnect 事件可能很多人就不太明白了。还记得上面讲到的进程优雅退出吗，当捕获到未处理异常时，进程不立即退出，但是会立刻通知 master 进程重新 fork 新的进程，而不是等该进程主动退出后再 fork。具体的做法就是调用 worker进程的 disconnect 方法，从而关闭父子进程用于通信的 channel ，此时父子进程之间失去了联系，此时master 进程会触发 disconnect 事件，fork 一个新的 worker进程。</p>
<p>下面是一个触发<code>disconnect</code>事件的简单 demo</p>
<p>master.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WriteWrap = process.binding(<span class="string">'stream_wrap'</span>).WriteWrap;</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">var</span> worker = fork(__dirname + <span class="string">'/worker.js'</span>);</span><br><span class="line">     worker.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[%s] worker %s is disconnected'</span>, process.pid, worker.pid);</span><br><span class="line">     &#125;);</span><br><span class="line">     workers.push(worker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handle = net._createServerHandle(<span class="string">'0.0.0.0'</span>, <span class="number">3000</span>);</span><br><span class="line">handle.listen();</span><br><span class="line">handle.onconnection = <span class="function"><span class="keyword">function</span> (<span class="params">err,handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> worker = workers.pop();</span><br><span class="line">    <span class="keyword">var</span> channel = worker._channel;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> WriteWrap();</span><br><span class="line">    channel.writeUtf8String(req, <span class="string">'dispatch handle'</span>, handle);</span><br><span class="line">    workers.unshift(worker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteWrap = process.binding(<span class="string">'stream_wrap'</span>).WriteWrap;</span><br><span class="line"><span class="keyword">const</span> channel = process._channel;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="string">'hello Node.js'</span>;</span><br><span class="line"><span class="keyword">var</span> res = [<span class="string">'HTTP/1.1 200 OK'</span>,<span class="string">'content-length:'</span> + buf.length].join(<span class="string">'\r\n'</span>) + <span class="string">'\r\n\r\n'</span> + buf;</span><br><span class="line"></span><br><span class="line">channel.ref(); <span class="comment">//防止进程退出</span></span><br><span class="line">channel.onread = <span class="function"><span class="keyword">function</span> (<span class="params">len, buf, handle</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'[%s] worker %s got a connection'</span>, process.pid, process.pid);</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> net.Socket(&#123;</span><br><span class="line">        handle: handle</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.readable = socket.writable = <span class="literal">true</span>;</span><br><span class="line">    socket.end(res);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'[%s] worker %s is going to disconnect'</span>, process.pid, process.pid);</span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>node master.js</code>启动服务器后，在另一个终端执行多次<code>curl http://127.0.0.1:3000</code>，下面是输出的内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">63240</span>] worker <span class="number">63240</span> got a connection</span><br><span class="line">[<span class="number">63240</span>] worker <span class="number">63240</span> is going to disconnect</span><br><span class="line">[<span class="number">63236</span>] worker <span class="number">63240</span> is disconnected</span><br></pre></td></tr></table></figure>
<h2 id="最简单的负载均衡_server">最简单的负载均衡 server</h2><p>回到前面讲的 round-robin 多进程服务器模型，用于通信的 channel 除了可以发送简单的字符串数据外，还可以发送文件描述符，</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.writeUtf8String(req, <span class="built_in">string</span>, <span class="literal">null</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>最后一个参数便是要传递的 fd。round-robin 多进程服务器模型的核心也正式依赖于这个特性。 在上面的 demo 基础上，我们再稍微加工一下，还原在 Node.js 中最原始的处理。</p>
<p>master.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WriteWrap = process.binding(<span class="string">'stream_wrap'</span>).WriteWrap;</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    workers.push(fork(__dirname + <span class="string">'/worker.js'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handle = net._createServerHandle(<span class="string">'0.0.0.0'</span>, <span class="number">3000</span>);</span><br><span class="line">handle.listen();</span><br><span class="line">handle.onconnection = <span class="function"><span class="keyword">function</span> (<span class="params">err,handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> worker = workers.pop();</span><br><span class="line">    <span class="keyword">var</span> channel = worker._channel;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> WriteWrap();</span><br><span class="line">    channel.writeUtf8String(req, <span class="string">'dispatch handle'</span>, handle);</span><br><span class="line">    workers.unshift(worker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>worker.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> WriteWrap = process.binding(<span class="string">'stream_wrap'</span>).WriteWrap;</span><br><span class="line"><span class="keyword">const</span> channel = process._channel;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="string">'hello Node.js'</span>;</span><br><span class="line"><span class="keyword">var</span> res = [<span class="string">'HTTP/1.1 200 OK'</span>, <span class="string">'content-length:'</span> + buf.length].join(<span class="string">'\r\n'</span>) + <span class="string">'\r\n\r\n'</span> + buf;</span><br><span class="line"></span><br><span class="line">channel.ref();</span><br><span class="line">channel.onread = <span class="function"><span class="keyword">function</span> (<span class="params">len, buf, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">new</span> net.Socket(&#123;</span><br><span class="line">        handle: handle</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.readable = socket.writable = <span class="literal">true</span>;</span><br><span class="line">    socket.end(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>node master.js</code>， 一个简单的多进程 Node.js web 服务器便跑起来了。</p>
<h2 id="小结">小结</h2><p>到此整个 Node.js 的多进程服务器模型，以及底层进程间通信原理就讲完了，也为大家揭开了 cluster 的神秘面纱， 相信大家对 cluster 有了更深刻的认识。祝大家 Node.js 的开发旅途上玩得更愉快！</p>
<p>附：上篇文章<a href="http://taobaofed.org/blog/2015/11/03/nodejs-cluster/">当我们谈论 cluster 时我们在谈论什么(上)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB17WhrKpXXXXXiXpXX2AXZ8pXX-900-500.png" alt="当我们谈论 cluster 时我们在谈论什么(下)"></p>
<p><a href="http:]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="cluster" scheme="http://taobaofed.org/tags/cluster/"/>
    
      <category term="多进程" scheme="http://taobaofed.org/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何评价页面的性能]]></title>
    <link href="http://taobaofed.org/blog/2015/11/09/web-performance/"/>
    <id>http://taobaofed.org/blog/2015/11/09/web-performance/</id>
    <published>2015-11-09T03:14:41.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1MByrKpXXXXc.aXXXXXXXXXXX-900-500.jpg" alt="如何评价页面的性能"></p>
<h2 id="引言">引言</h2><p>前端页面的性能一直都是一个热议的话题，从老早的“军规”开始我们就一直在关注页面的性能问题。</p>
<p>在前面巨人们的身后每个人也有自己的一些页面性能的经验，本文主要是介绍如何评估页面加载完成之后的性能。</p>
<h3 id="浏览器如何渲染一个页面">浏览器如何渲染一个页面</h3><p>先附上一张图片：</p>
<p><img src="https://img.alicdn.com/tps/TB1WlKAKpXXXXctXVXXXXXXXXXX-670-281.png" alt="image"></p>
<p>这是在网上找的一张图，虽然是用来描述 performance 的 API 但是也很好的描述了浏览器是怎么处理一个页面渲染的。</p>
<p>这是我们在 PC 时代考虑的浏览器性能，主要在服务端响应、文档下载、文档渲染三个阶段，性能优化大部分也集中在这三个阶段。针对这部分的监控、分析非常的普遍了，在 <a href="http://taobaofed.org/blog/2015/10/28/jstracker-how-to-collect-data/">JSTracker</a> 上也有这个数据的分析。</p>
<p>为什么刚才说 PC 时代呢，除了这些指标作为前端还有需要关注的什么性能呢？</p>
<p>页面加载之后的操作体验！（注：这里的加载之后近似在 onLoad 之后）</p>
<h3 id="页面操作的流畅度">页面操作的流畅度</h3><p>在 PC 的 CPU 越来越牛逼、内存越来越大的时候，前端的代码复杂度也在上升。</p>
<p>以往我们都默认认为只要资源加载好了、只要资源加载快了那么我们的页面性能就是棒棒哒的，现在不再是这样。</p>
<p>这里涉及到两个问题：</p>
<ul>
<li>PC 端的 CPU 性能、内存的性能虽然很高了，但是前端代码也更复杂了；</li>
<li>除了 PC，还有无线端；</li>
</ul>
<p>于是我们的性能指标多了一项：页面流畅度。</p>
<h3 id="页面流畅度如何感知">页面流畅度如何感知</h3><p>卡顿的感受会在很多地方出现，比如：</p>
<ul>
<li>你在逛某个页面的时候愉快的的滚动鼠标滚轮，但是页面会突然的顿一下。</li>
<li>你在打开手机上直接访问 PC 页面（或者 H5 页面）的时候，发现浏览器就像死掉了一样。</li>
</ul>
<p>拿两个 PC 页面来感受一下卡顿：</p>
<p>页面 1：<a href="http://codepen.io/taobaofed/pen/jbeQbN" target="_blank" rel="external">http://codepen.io/taobaofed/pen/jbeQbN</a></p>
<p>页面 2：<a href="http://codepen.io/taobaofed/pen/JYmeYJ" target="_blank" rel="external">http://codepen.io/taobaofed/pen/JYmeYJ</a></p>
<p>很明显页面 1 比页面 2 卡顿很多。</p>
<p>卡顿就是这样的感觉，但是怎么来衡量这个卡顿的程度呢？</p>
<p>总不能让用户直接说吧，就像上面的两个页面：有人开心的时候会说都很流畅，要是不开心的时候他会说两个都有点卡顿。这样的评价太主观了。</p>
<h3 id="如何客观的度量页面卡顿程度">如何客观的度量页面卡顿程度</h3><p>首先要知道页面为什么会卡顿呢？</p>
<p>我们还是以上面两个页面做比较，看看浏览器里面的 Timeline;</p>
<p>页面 1：</p>
<p><img src="https://img.alicdn.com/tps/TB17K5YKpXXXXafXpXXXXXXXXXX-890-411.png" alt="image"></p>
<p>页面 2：</p>
<p><img src="https://img.alicdn.com/tps/TB1EM5HKpXXXXX0XVXXXXXXXXXX-891-180.png" alt="image"></p>
<p>这两个页面的渲染 FPS 可以看出来，的确第一个页面很卡。一般我们要求页面要达到 60 FPS（ 60 帧/秒）。上面说到页面 2 其实也是有稍微的卡顿的，只不过比页面 1 好很多。</p>
<p>如果按照 60 FPS 计算，那么每一帧执行时间为 1/60s，也就是 16.7ms。</p>
<h3 id="为什么页面会看起来比较卡">为什么页面会看起来比较卡</h3><p>浏览器的渲染是单线程的，在某一个时刻要么在进行 JS 运算，要么在进行 UI 渲染。不会同时进行。</p>
<p>如果我们的脚本在改变 UI 那么这个脚本的执行时间不要超过了 16.7ms，否则页面在这个周期中无法进行 UI 变化，那么看起来就是跳帧（卡顿）了。</p>
<p>如果你的页面没有改变 UI ，情况会好很多，浏览器看起来就是失去了响应，Hover 滚动都动不了了。</p>
<p>准备了一个简单的代码，用来说明如果脚本执行超过 16.7ms 会有什么感觉：</p>
<p>页面 3：<a href="http://codepen.io/taobaofed/pen/YyJJzW" target="_blank" rel="external">http://codepen.io/taobaofed/pen/YyJJzW</a></p>
<p>在这里例子中两个按钮的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按钮1</span></span><br><span class="line">$(<span class="string">'#do'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#status'</span>).text(<span class="string">'calculating....'</span>); </span><br><span class="line">  setTimeout(long,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//按钮2</span></span><br><span class="line">$(<span class="string">'#do2'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#status'</span>).text(<span class="string">'calculating....'</span>); </span><br><span class="line">  long();</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>点击第一个按钮，下方文字会立即变为“calculating….”</p>
<p>点击第二个按钮，下方的文字跳过了变为“calculating….”阶段，直接变为“calclation done”。而且按钮的 Active 状态都不会消失，直到脚本执行完成。</p>
<p>为什么会出现这样的结果呢？</p>
<p>这个就是浏览器的单进程模式确定的，setTimeout 把要执行的任务扔到浏览器的单线程的队列尾部，线程能够有机会渲染 UI ！（图片来自参考文章 3）</p>
<p><img src="https://img.alicdn.com/tps/TB1kUSTKpXXXXbVXpXXXXXXXXXX-674-368.png" alt="image"></p>
<p>第一个按钮点击之后 UI 渲染能够马上的得到运行时间，第二个按钮点击之后 UI 渲染必须要等到 long 方法执行完毕，所以看起来像是浏览器卡死了。</p>
<h3 id="如何采集页面卡顿的程度">如何采集页面卡顿的程度</h3><p>目前为止，我们已经知道了什么是卡顿、卡顿的发生原因、如何在 Chrome 中查看卡顿，接下来我们要想办法用 JS 获取页面的卡顿程度。</p>
<p>利用上述的原理：浏览器是单线程的，如果卡顿发生了那么后面队列堆积的方法就得不到执行。</p>
<p>假如我们配置一个定时器，每隔一段时间 t 就向浏览器的线程队列中丢一个方法进去：</p>
<ul>
<li>如果线程队列是空闲的，那么我们理论上可以检查到我们的方式每次都是准时的间隔 t 被调用一次；</li>
<li>如果线程队列是繁忙的，那么这个间隔时间将是大于 t 的；</li>
</ul>
<p>试验方案有了，接下来进行试验。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">  t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>还是刚才的页面 3， 请打开控制台看看：<br>当点击按钮的时候控制台的 console 会停止，隔一会儿再输出数据，而且的确如我们预料的间隔时间变长了。</p>
<p><img src="https://img.alicdn.com/tps/TB1PwyIKpXXXXXsXVXXXXXXXXXX-316-217.png" alt="image"></p>
<p>有兴趣的同学可以打开页面 1、页面 2 的控制台也可以看到数据。</p>
<p>接下来的事情是把这些数据收集起来，形成一个指标。这事情就好办多了：</p>
<ul>
<li>统计页面一段时间的这些 t 值的和，可以计算出页面的拥堵程度，这个值理论上是和 CPU 的时间消耗成正比的，所以我们定义这个值为 CPU 消耗；</li>
<li>统计这些 t 值在什么时候开始归于平静，这个值也就是浏览器线程开始闲下来的时间，我们定义这个值为页面可操作时间；</li>
<li>统计一段时间这些 t 值超过某个阈值的次数，比如设置的间隔是 100ms，t 值过了 200 的次数和总次数的比。我们定义这个值为页面渲染的 CPU 占比；</li>
</ul>
<h3 id="数据可视化">数据可视化</h3><p>一些浏览器是不能直接看到 console 的，比如手机浏览器。于是我们提供一个小插件（bookmarklet）。</p>
<p>页面 4：<a href="http://codepen.io/taobaofed/pen/xwyQwd" target="_blank" rel="external">http://codepen.io/taobaofed/pen/xwyQwd</a></p>
<p>然后打开任意页面可以看到这个：</p>
<p><img src="https://img.alicdn.com/tps/TB1_GOBKpXXXXb8XVXXXXXXXXXX-408-133.png" alt="image"></p>
<h3 id="数据统计">数据统计</h3><p>这个数据目前已经纳入到到 JSTracker 的性能数据中。</p>
<p>Taobao 首页的数据：</p>
<p><img src="https://img.alicdn.com/tps/TB10a1vKpXXXXbcaXXXXXXXXXXX-1043-463.png" alt="image"></p>
<h3 id="如何优化">如何优化</h3><p>原则是每段连续执行的 JS 都尽量在 16.7ms 内完成，主要可以按以下方案进行：</p>
<h4 id="减少会引起页面重绘（redraw）的方法的调用">减少会引起页面重绘（redraw）的方法的调用</h4><p>这些值的列表如下（不完整，如果你不确定可以写个循环测试一下）：</p>
<p>clientHeight, clientLeft, clientTop, clientWidth, focus(), getBoundingClientRect(), getClientRects(), innerText, offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth, outerText, scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth</p>
<p>如果要使用尽量吧这些值缓存起来，不要再循环中直接调用。（有兴趣的同学可以对比一下页面 1 和页面 2 的区别，其实只有一行）。<br>除了缓存还可以像页面 2 一样，直接不去获取，因为这些值可能我们是能够预测的，不要要再让浏览器计算。</p>
<h4 id="将某些耗时的操作放到空闲的时候再去做（requestAnimationFrame、setTimout）">将某些耗时的操作放到空闲的时候再去做（requestAnimationFrame、setTimout）</h4><p>如页面 3 让 UI 渲染能够有 CPU 时间执行。</p>
<p>但是如果你的这个耗时计算耗时太长了你可以考虑是否能将一些不是立即需要的任务分拆掉，平均的分配到各个帧。</p>
<p><img src="https://img.alicdn.com/tps/TB1__q4KpXXXXa4XXXXXXXXXXXX-472-217.png" alt="image"></p>
<h4 id="涉及到页面的动画元素能用_GPU_最佳">涉及到页面的动画元素能用 GPU 最佳</h4><p>我们可以给某些元素加上：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-webkit-transform</span>: <span class="tag">translateZ</span>(0);</span><br></pre></td></tr></table></figure>
<p>强制让浏览器用 GPU 渲染这个层，不过这样做要适量，多了也容易出问题。（参考： <a href="http://wesleyhales.com/blog/2013/10/26/Jank-Busting-Apples-Home-Page/" target="_blank" rel="external">http://wesleyhales.com/blog/2013/10/26/Jank-Busting-Apples-Home-Page/</a> ）</p>
<h4 id="釜底抽薪：降级">釜底抽薪：降级</h4><p>你可以通过某种方式检测到浏览器太卡了，那么降级之……</p>
<h3 id="这个监控对页面本身性能的影响">这个监控对页面本身性能的影响</h3><p>由于页面被注入了这个一个定时器，可能会对页面造成影响的，虽然这个影响非常低但是还是必须要考虑：</p>
<p>第一层，强力优化这部分代码的性能：</p>
<p>在定时器中执行的任务都是纯 JS 运算，我们统计过这个部分的代码的消耗平均不到 0.04ms，占一帧时间的 0.23%。</p>
<p><img src="https://img.alicdn.com/tps/TB1.hKIKpXXXXXBXVXXXXXXXXXX-253-162.png" alt="image"></p>
<p><img src="https://img.alicdn.com/tps/TB1a.qLKpXXXXbhXFXXXXXXXXXX-193-300.png" alt="image"></p>
<p>第二层，抽样少量的数据进行数据采集，目前采样 1% 的。</p>
<h3 id="参考文章">参考文章</h3><ul>
<li><a href="http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering" target="_blank" rel="external">http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering</a></li>
<li><a href="http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles" target="_blank" rel="external">http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles</a></li>
<li><a href="http://blog.sae.sina.com.cn/archives/2394" target="_blank" rel="external">http://blog.sae.sina.com.cn/archives/2394</a></li>
<li><a href="http://www.cnblogs.com/Mainz/p/3552717.html" target="_blank" rel="external">http://www.cnblogs.com/Mainz/p/3552717.html</a></li>
<li>bookmarklet 插件借鉴 <a href="http://ued.taobao.org/blog/2012/06/7th_d2/" target="_blank" rel="external">http://ued.taobao.org/blog/2012/06/7th_d2/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1MByrKpXXXXc.aXXXXXXXXXXX-900-500.jpg" alt="如何评价页面的性能"></p>
<h2 id="引言">引言</h2><p>前端页面的性能一直都是一个热议的]]>
    </summary>
    
      <category term="performance" scheme="http://taobaofed.org/tags/performance/"/>
    
      <category term="页面性能" scheme="http://taobaofed.org/tags/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSTracker 之异常数据处理]]></title>
    <link href="http://taobaofed.org/blog/2015/11/06/jstracker-data-processing/"/>
    <id>http://taobaofed.org/blog/2015/11/06/jstracker-data-processing/</id>
    <published>2015-11-06T11:03:57.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms03.alicdn.com/tps/i3/TB1.AG_KpXXXXXdXXXX2AXZ8pXX-900-500.png" alt="JSTracker 之异常数据处理"></p>
<p>上一篇：<a href="http://taobaofed.org/blog/2015/10/28/jstracker-how-to-collect-data/">JSTracker 之前端异常数据采集</a></p>
<p>前文已经解决了采集数据的问题了，但是采集到的数据不做分析是体现不出价值的。接下来会介绍 JSTracker 的数据处理部分。</p>
<p>大概会按照以下目录：</p>
<ul>
<li>服务端如何接受数据</li>
<li>数据存储</li>
<li>报警</li>
<li>定位</li>
</ul>
<p>JSTracker的系统流程图：</p>
<p><img src="http://gtms03.alicdn.com/tps/i3/TB1nhumKpXXXXX3XpXXlErfIVXX-600-264.png" alt="JSTracker的系统流程图"></p>
<h3 id="服务端如何接受数据">服务端如何接受数据</h3><p>日志上报需要服务端提供一个 http 接口，将前端采集到的数据统一的发回服务端。</p>
<p>需要注意的是如果你用 GET 请求发送数据，那么 URL 的长度是有限的，建议的安全值是2000（ 没有对所有的浏览器测试，最低的是 IE ）。</p>
<p>如果你需要上报的数据量特别大可以考虑用 POST 请求。</p>
<h3 id="接收到的数据原始数据解析">接收到的数据原始数据解析</h3><p>在 JSTracker 中，服务端采集到日志之后，提供了一个接口可以读取数据流。 这个接口是一个队列，队列的生产端不停地采集数据，队里的消费端就是 JSTracker。</p>
<p>只要消费数据的速度足够快就能接近实时的获取到上报的日志。</p>
<p>拿到的日志我们需要对数据进行基础的加工，比如把原始浏览器信息解析分类（当然这一步其实也可以在采集数据的时候做掉）。</p>
<p>对于前端来说，用 Node 无疑是最好的。JSTracker 对日志的分析压测能够到900 QPS （用的是一台8核16G的机器测试）。</p>
<h3 id="数据存储">数据存储</h3><p>虽然进行了数据采集的抽样，但是数据的大小还是会达到每天亿级别的数据。对于前端来说熟悉的 Mysql、Mongo 等等方案已经不能满足这么大的读写了。</p>
<p>最初的时候的时候 JSTracker 是使用的 Mysql ，但是单机写入速度和查询速度都无法满足需求，后来找到了开源方案基于 levelDB 的 SSDB （ <a href="https://github.com/ideawu/ssdb" target="_blank" rel="external">https://github.com/ideawu/ssdb</a> ）。如果你的服务托管在阿里云还可以考虑使用阿里云的 OTS ( <a href="http://www.aliyun.com/product/ots/" target="_blank" rel="external">http://www.aliyun.com/product/ots/</a> )。</p>
<h3 id="报警">报警</h3><p>JSTracker 会基于 Midway 检查每一条日志是否需要触发报警。报警方案主要有两种：</p>
<ul>
<li>默认方案：会基于影响用户数、PV、历史数据做判断，阈值会设置比较大。实际应用中会动态的调整这个阈值</li>
<li>绝对值方案：有些报错是0容忍的，那么会设置这个错误在达到一定次数直接报警，比如设置在10min内超过10条日志就报警</li>
</ul>
<p>报警可以通过邮件、短信渠道通知到对应的人。</p>
<p>报警需要解决重复报警，有几种情况：</p>
<ul>
<li>如果这个 URL 是初次接入，由于没有历史基线数据，会不会直接触发报警</li>
<li>如果一个报警触发了，那么如何避免连续报警</li>
<li>如果一个峰值是历史常态，如何让系统认识到这是一个常态，不是异常</li>
</ul>
<p>针对上面三条，其实处理起来也不是非常复杂：</p>
<ul>
<li>初次接入的 URL 由于没有基线，那么不报警，除非它超过了一个很高的特殊阈值</li>
<li>一个报警发生了，会有一条报警记录，要出发报警之前检查一下这个数据就能避免重复了，JSTracker 会在 1 小时内部重复报警</li>
<li>由于我们是比较历史基线数据的，大约一段时间后基线数据就会变得和这个数据一致了（木有涉及机器学习，这个还不必要），比如下面某URL的历史基线（蓝色）</li>
</ul>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB10uqbKpXXXXbiXFXXlV4XLFXX-923-280.png" alt="历史基线数据学习"></p>
<p>上图中的有些特殊时刻数据量会偏高，经过一段时间的数据沉淀，在这个时刻不会再触发报警了。</p>
<h3 id="报错定位">报错定位</h3><p>当你收到一个报警之后坑定会想知道发生了什么。</p>
<p>如果你是自己打的日志，那很清晰明了，不用担心找不到问题。</p>
<p>比如这样：</p>
<p><img src="http://gtms04.alicdn.com/tps/i4/TB1Y1N2KpXXXXcxXVXX4Yx.6XXX-750-60.png" alt="自己打的日志"></p>
<p>如果你收到的错误是这样：</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1onNUKpXXXXcmaXXX4Yx.6XXX-750-60.png" alt="onError采集到的报错"></p>
<p>那可能你会头疼一下了，这个是压缩后的代码，完全看不明白这是什么报错。定位压缩后的代码肯定需要祭出 sourceMap 这个神器了。</p>
<p>在我们已知文件、行号、列号的情况下，通过 sourceMap 就可以拿到还原后的代码了。如下图，进入一个报错的时候会定位到某一列。</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1AJ9vKpXXXXXWXXXXh3ObOpXX-579-445.png" alt="sourceMap还原"></p>
<h3 id="数据展现">数据展现</h3><p>JSTracker 做为一个报警系统，最理想的情况就是它默默的在后面运行就好了，大家都不知道他存在是最好的了。但是一旦有报警还是需要有页面可以查看，界面上直接用 Bootstrap 加上开源的图表组件基本就可以了 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms03.alicdn.com/tps/i3/TB1.AG_KpXXXXXdXXXX2AXZ8pXX-900-500.png" alt="JSTracker 之异常数据处理"></p>
<p>上一篇：<a href="http://ta]]>
    </summary>
    
      <category term="JSTracker" scheme="http://taobaofed.org/tags/JSTracker/"/>
    
      <category term="工具&amp;平台" scheme="http://taobaofed.org/categories/%E5%B7%A5%E5%85%B7-%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 常见网络错误信息]]></title>
    <link href="http://taobaofed.org/blog/2015/11/05/nodejs-errors/"/>
    <id>http://taobaofed.org/blog/2015/11/05/nodejs-errors/</id>
    <published>2015-11-05T02:24:01.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="//gtms03.alicdn.com/tps/i3/TB16M4LKpXXXXcEXFXX2AXZ8pXX-900-500.png" alt="Node.js 常见网络错误信息"></p>
<h2 id="1-介绍">1.介绍</h2><p>熟悉 Node.js 的同学一定见过 <code>ETIMEDOUT</code>、<code>EADDRINUSE</code> 等错误提示，那么这些错误信息到底是什么呢？答案其实很简单，因为 Node.js 底层使用的是<a href="http://www.gnu.org/software/libc/" target="_blank" rel="external"> glibc 库</a>，这些错误信息都是 glibc 库在 socket 连接时使用的 connect 函数中定义的错误类型，当然，v8在使用glibc库时也会加入一些自定义的错误类型，但许多错误情况还是和glibc中的定义一致的。</p>
<p><code>connect</code> 函数的定义为：<code>int connect (int socket, struct sockaddr addr, socklen_t length)</code></p>
<p><code>connect</code> 函数会使用文件描述符（file descriptor）<code>socket</code>表示的 socket 发起连接，socket 地址通过 <code>addr</code> 和 <code>length</code> 这两个参数来指定。（这个 socket 一般是其他机器的 socket，而且必须已经配置成了服务器）。</p>
<p>一般情况下，<code>connect</code> 函数会等待服务器响应请求才返回。当然也可以将 <code>socket</code> 设置为非阻塞模式来不等待响应就快速返回（可以参考下 nginx 是怎么使用 socket 的）。</p>
<h2 id="2-错误类型">2.错误类型</h2><p><code>connect</code> 函数正常的返回值为 0，在有错误时会返回 -1。函数中定义了如下错误条件：</p>
<ul>
<li><p><code>EBADF</code>：socket 不是有效的文件描述符（file descriptor）。</p>
</li>
<li><p><code>ENOTSOCK</code>：文件描述符 <code>socket</code> 不是 socket 。</p>
</li>
<li><p><code>EADDRNOTAVAIL</code>：指定的地址在远程机器上不可用。</p>
</li>
<li><p><code>EAFNOSUPPORT</code>：socket 不支持 <code>addr</code> 的命名空间。</p>
</li>
<li><p><code>EISCONN</code>：socket 已经连接。</p>
</li>
<li><p><code>ETIMEDOUT</code>：连接尝试超时。</p>
</li>
<li><p><code>ECONNREFUSED</code>：服务器主动拒绝建立连接。</p>
</li>
<li><p><code>ENETUNREACH</code>：从本机到给定 <code>addr</code> 的网络不通。</p>
</li>
<li><p><code>EADDRINUSE</code>：给定 <code>addr</code> 的 socket 地址已经在使用。（这种错误最常见，我们有时候本地已经启动了一个 Node.js 程序，再次启动会看到这个错误，也就是端口号已经被占用了）</p>
</li>
<li><p><code>EINPROGRESS</code>：socket 是非阻塞的，连接不能立即建立。可以使用 <code>select</code> 来确定连接完全建立的时间。参考<a href="http://www.gnu.org/software/libc/manual/html_node/Waiting-for-I_002fO.html#Waiting-for-I_002fO" target="_blank" rel="external">等待I/O</a>。在连接完全建立前如果在相同的 socket 上调用 connect，会以 <code>EALREADY</code> 失败。</p>
</li>
<li><p><code>EALREADY</code>：socket 是非阻塞的而且有一个挂起的连接（参考上面的 <code>EINPROGRESS</code>）。</p>
</li>
</ul>
<h2 id="3-注意">3.注意</h2><p>connect 是作为多线程程序的取消点定义的，开发者需要确保线程取消后释放了占用的资源（例如内存、文件描述符、<a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank" rel="external">semaphore</a>)等）。</p>
<h3 id="参考资料">参考资料</h3><ul>
<li><p><a href="http://www.gnu.org/software/libc/manual/html_node/Connecting.html" target="_blank" rel="external">libc: Making a Connection</a></p>
</li>
<li><p><a href="http://www.gnu.org/software/libc/manual/html_node/Socket-Addresses.html#Socket-Addresses" target="_blank" rel="external">socket 地址解析</a></p>
</li>
<li><p><a href="http://www.gnu.org/software/libc/manual/html_node/File-Status-Flags.html#File-Status-Flags" target="_blank" rel="external">文件状态标记</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="//gtms03.alicdn.com/tps/i3/TB16M4LKpXXXXcEXFXX2AXZ8pXX-900-500.png" alt="Node.js 常见网络错误信息"></p>
<h2 id="1-介绍">1.介绍</h2><p>熟悉 No]]>
    </summary>
    
      <category term="EDDRINUSE" scheme="http://taobaofed.org/tags/EDDRINUSE/"/>
    
      <category term="ETIMEDOUT" scheme="http://taobaofed.org/tags/ETIMEDOUT/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="errors" scheme="http://taobaofed.org/tags/errors/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[rem 产生的小数像素问题]]></title>
    <link href="http://taobaofed.org/blog/2015/11/04/mobile-rem-problem/"/>
    <id>http://taobaofed.org/blog/2015/11/04/mobile-rem-problem/</id>
    <published>2015-11-04T01:48:28.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB1fEFLKpXXXXa2XXXXlzJZ8pXX-900-500.jpg" alt="rem 产生的小数像素问题"></p>
<p>由于日常需求以无线居多，所以可以在业务中做一些尝试，如 rem，刚接触这个特性的时候，曾经一度爱不释手，仿佛在无线开发的坎坷路上寻找到一条捷径。然而随着使用范围的扩大，慢慢的发现了一些使用 rem 带来的问题。</p>
<h3 id="rem">rem</h3><p>关于 rem 这个单位的介绍，在此就不赘述，有兴趣的同学可以阅读一丝的<a href="http://ued.taobao.org/blog/2013/05/rem-font-size/" target="_blank" rel="external">《响应式十日谈第一日：使用 rem 设置文字大小》</a>，文章对 rem 进行了详细的介绍。</p>
<h3 id="用途">用途</h3><p>在无线开发中，响应式布局尤为重要，先不说屏幕尺寸越来越多样化的 iPhone，单是安卓就有 N 多种尺寸要适配。</p>
<p>在没有使用 rem 之前，想要按照设计师的想法去适配不同 分辨率<sup>1</sup> 是一件非常难操作的事情。用了 rem 以后，一切简单了许多，你可以用它来设置元素的宽高、间距…，然后针对不同的分辨率计算并设置相对应的根字体大小，然后元素就好像缩放过一样自动适应了当前的分辨率，大大的降低了适配工作量。</p>
<p>Demo：</p>
<p><img src="http://gtms04.alicdn.com/tps/i4/TB1JyFIKpXXXXaYXpXXcD1K8pXX-900-900.jpg" alt=""></p>
<p>上图是同一个页面在 Apple iPhone 5 和 Samsung Galaxy S4 两款机器下的效果，可以看出从 320px 宽的 iPhone 5 到 360px 宽的 S4，图片像是等比放大了一样，我们分析下这个原理：</p>
<p>假定<sup>2</sup> width=320px 的分辨率下的根字体大小是 32px，由此推算：</p>
<ul>
<li><p>width=320px 分辨率下：</p>
<p>  根字体大小是 32px，该分辨率下宽 1rem 的元素在浏览器里的真实宽度就是 1 * 32 = 32px；</p>
</li>
<li><p>width=360px 分辨率下：</p>
<p>  如果要达到等比放大的效果，宽 1rem 的元素在浏览器里的真实宽度就应该是 32 * (360/320) = 36px，由此得出 width=360px 分辨率下的根字体大小为 36px； </p>
</li>
</ul>
<p>由此可见等比缩放是通过控制根字体大小来实现的，且根字体大小与屏幕宽度成正比。</p>
<h3 id="小数像素">小数像素</h3><p>刚才举的例子里面 1rem 在 width=320px 分辨率下的真实尺寸为 32px，在 width=360px 分辨率下的真实尺寸为 36px，均为整数。</p>
<p>如果是 1.75rem 呢？</p>
<table>
<thead>
<tr>
<th>代表机型</th>
<th>浏览器宽</th>
<th>对应尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPhone 4/4s/5/5s</td>
<td>320px</td>
<td>56px</td>
</tr>
<tr>
<td>Samsung Note 3, Nexus 5…</td>
<td>360px</td>
<td>63px</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>375px</td>
<td>65.625px</td>
</tr>
<tr>
<td>Google Nexus 6</td>
<td>412px</td>
<td>72.1px</td>
</tr>
<tr>
<td>iPhone 6 Plus</td>
<td>414px</td>
<td>72.45px</td>
</tr>
</tbody>
</table>
<p>可以看到部分机型下出现了小数像素，那么浏览器是如何处理小数像素的呢？</p>
<p><img src="http://gtms04.alicdn.com/tps/i4/TB1z44zKpXXXXbhXFXXIAQPVXXX-415-758.jpg" alt=""></p>
<p>如图，第一组每个色块的大小为 1.75rem x 1.75rem，第二组每个色块的大小为 1.85rem x 1.85rem；</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1ztXTKpXXXXaqXXXXUs_wVVXX-312-248.jpg" alt=""></p>
<p>先看第一组色块，在 iPhone 6 下，其在浏览器内的渲染尺寸应该是 1.75 * 37.5 = 65.625px；</p>
<p><img src="http://gtms03.alicdn.com/tps/i3/TB19S8KKpXXXXXfXpXXq6fcLFXX-816-300.jpg" alt=""></p>
<p>但真实渲染尺寸却是另外一种情况：有的宽度是 66px，有的却是 65px，而且顺序上毫无规律。</p>
<p>这一结果让我十分疑惑，如果浏览器统一做四舍五入处理，那么所有的色块尺寸也应该是一样的，不会出现部分向上取整，部分向下取整。</p>
<p>思考许久无果，大胆设想了一下：浏览器在渲染时所做的舍入处理只是应用在元素的渲染尺寸上，其真实占据的空间依旧是原始大小。</p>
<p>也就是说如果一个元素尺寸是 0.625px，那么其渲染尺寸应该是 1px，空出的 0.375px 空间由其临近的元素填充；同样道理，如果一个元素尺寸是 0.375px，其渲染尺寸就应该是 0，但是其会占据临近元素 0.375px 的空间。于是就顺着这个思路验证了以下：</p>
<ol>
<li>第一个色块的宽度为 65.625px，根据四舍五入的原则其最终渲染尺寸为 66px，空出的 0.375px 由第二个色块补上；</li>
<li>第二个色块向左补进 0.375px，相当于减少了 0.375px，余下 65.25px，根据四舍五入的原则其最终渲染尺寸为 65px，多出的 0.25px 会占用第三个色块的空间；</li>
<li>第三个色块被占用了 0.25px，相当于增加了 0.25px，等于 65.875px，根据四舍五入的原则其最终渲染尺寸为 66px，空出的 0.125px 由第四个色块补上；</li>
<li>第四个色块向左补进 0.125px，相当于减少了 0.125px，余下 65.5px，根据四舍五入的原则其最终渲染尺寸为 66px，空出的 0.5px 由第五个色块补上；</li>
<li>第五个色块向左补进 0.5px，相当于减少了 0.5px，余下 65.125px，根据四舍五入的原则其最终渲染尺寸为 65px，多出 0.125px；</li>
</ol>
<p>上述验证与浏览器输出结果完全一致，表明浏览器在处理小数像素的时候并不是直接舍入处理的，元素依旧占据着应有的空间，只是在计算元素尺寸的时候做了舍入处理（后来在看到 <a href="http://trac.webkit.org/wiki/LayoutUnit" target="_blank" rel="external">LayoutUnit – WebKit</a> 这篇文档后，也印证了之前的假设）。</p>
<p>你可以参考上述原理对第二组色块进行验证，然后比对<a href="http://gtms04.alicdn.com/tps/i4/TB1_bROKpXXXXcKXXXXI7HiPpXX-688-398.jpg" target="_blank" rel="external">结果</a>。</p>
<h3 id="问题">问题</h3><p>目前遇到最多的问题就是 background-image 的问题，经常会因为小数像素导致背景图被裁掉一部分。</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1kSxDKpXXXXaPXFXXP1JQ7FXX-1332-900.png" alt=""></p>
<p>上图是同一组 icon 在不同机型下的效果，可以看出这些 icon 在 iPhone 5 和 Galaxy S4 下或多或少的会被裁掉一部分，原因就是由于小数像素导致的，这点可以从元素的 <a href="http://gtms03.alicdn.com/tps/i3/TB1deRSKpXXXXcbXXXX8D4i0VXX-640-620.png" target="_blank" rel="external">Computed Style</a> 上看出。</p>
<h3 id="解决">解决</h3><p>如何避免这种问题呢？以下两点建议：</p>
<ul>
<li>使用 <a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>；</li>
<li>如需使用 background-image，尽量为背景图设置一定的空白间隙，如图：<br><img src="http://gtms01.alicdn.com/tps/i1/TB1HhNEKpXXXXaSXFXX5XBmJVXX-920-840.png" alt=""></li>
</ul>
<h3 id="小结">小结</h3><p>小数像素产生的问题不单单只有 background-image，还会有其他尚未遇到的坑，然而在了解了浏览器是如何处理小数像素的原理以后，此类问题就变得很好解决，也非常可控。</p>
<h3 id="注:">注:</h3><ol>
<li>文中出现的分辨率都是指浏览器分辨率，关于逻辑分辨率、物理分辨率之间的关系可以参考：<a href="http://www.zhihu.com/question/27261444/answer/35898885" target="_blank" rel="external">「像素」「渲染像素」以及「物理像素」是什么东西？它们有什么联系？</a>；</li>
<li>为了保证大部分分辨率下计算出的根字体大小都为整数，所以约定根字体大小的计算公式为：分辨率宽度 / 10；</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB1fEFLKpXXXXa2XXXXlzJZ8pXX-900-500.jpg" alt="rem 产生的小数像素问题"></p>
<p>由于日常需求以无线居多，所以可以在业务中做一些尝试，]]>
    </summary>
    
      <category term="rem" scheme="http://taobaofed.org/tags/rem/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[当我们谈论 cluster 时我们在谈论什么(上)]]></title>
    <link href="http://taobaofed.org/blog/2015/11/03/nodejs-cluster/"/>
    <id>http://taobaofed.org/blog/2015/11/03/nodejs-cluster/</id>
    <published>2015-11-03T01:38:25.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB17WhrKpXXXXXiXpXX2AXZ8pXX-900-500.png" alt="当我们谈论 cluster 时我们在谈论什么(上)"></p>
<p>Node.js 诞生之初就遭到不少这样的吐槽，当然这些都早已不是问题了。</p>
<blockquote>
<p>1、可靠性低。<br>2、单进程，单线程，只支持单核 CPU，不能充分的利用多核 CPU 服务器。一旦这个进程崩掉，那么整个 web 服务就崩掉了。</p>
</blockquote>
<p>回想以前用 php 开发 web 服务器的时候，每个 request 都在单独的线程中处理，即使某一个请求发生很严重的错误也不会影响到其它请求。Node.js 会在一个线程中处理大量请求，如果处理某个请求时产生一个没有被捕获到的异常将导致整个进程的退出，已经接收到的其它连接全部都无法处理，对一个 web 服务器来说，这绝对是致命的灾难。</p>
<p>应用部署到多核服务器时，为了充分利用多核 CPU 资源一般启动多个 Node.js 进程提供服务，这时就会使用到 Node.js 内置的 cluster 模块了。相信大多数的 Node.js 开发者可能都没有直接使用到 cluster，cluster 模块对 child_process 模块提供了一层封装，可以说是为了发挥服务器多核优势而量身定做的。简单的一个 fork，不需要开发者修改任何的应用代码便能够实现多进程部署。当下最热门的带有负载均衡功能的 Node.js 应用进程管理器 pm2 便是最好的一个例子，开发的时候完全不需要关注多进程场景，剩余的一切都交给 pm2 处理，与开发者的应用代码完美分离。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 <span class="literal">start</span> app.js</span><br></pre></td></tr></table></figure>
<p>pm2 确实非常强大，但本文并不讲解 pm2 的工作原理，而是从更底层的进程通信讲起，为大家揭秘使用 Node.js 开发 web 应用时，使用 cluster 模块实现多进程部署的原理。</p>
<h2 id="fork">fork</h2><p>说到多进程当然少不了 fork ,在 un*x 系统中，fork 函数为用户提供最底层的多进程实现。</p>
<blockquote>
<p>fork() creates a new process by duplicating the calling process.  The new process is referred to as the child process.  The calling process is referred to as the parent process.</p>
<p>The child process and the parent process run in separate memory spaces.  At the time of fork() both memory spaces have the same content. Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect the other.</p>
</blockquote>
<p>本文中要讲解的 fork 是 cluster 模块中非常重要的一个方法，当然了，底层也是依赖上面提到的 fork 函数实现。 多个子进程便是通过在master进程中不断的调用 cluster.fork 方法构造出来。下面的结构图大家应该非常熟悉了。</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1XNnNJVXXXXanXpXXQzA.9VXX-447-300.png" alt="多进程服务器模型"><br>上面的图非常粗糙， 并没有告诉我们 master 与 worker 到底是如何分工协作的。Node.js 在这块做过比较大的改动，下面就细细的剖析开来。</p>
<h3 id="多进程监听同一端口">多进程监听同一端口</h3><p>最初的 Node.js 多进程模型就是这样实现的，master 进程创建 socket，绑定到某个地址以及端口后，自身不调用 listen 来监听连接以及 accept 连接，而是将该 socket 的 fd 传递到 fork 出来的 worker 进程，worker 接收到 fd 后再调用 listen，accept 新的连接。但实际一个新到来的连接最终只能被某一个 worker 进程 accpet 再做处理，至于是哪个 worker 能够 accept 到，开发者完全无法预知以及干预。这势必就导致了当一个新连接到来时，多个 worker 进程会产生竞争，最终由胜出的 worker 获取连接。</p>
<p><img src="http://gtms04.alicdn.com/tps/i4/TB1bexvKpXXXXaMXXXX3GwW0VXX-426-298.png" alt="多进程监听同一端口"></p>
<p>为了进一步加深对这种模型的理解，我编写了一个非常简单的 demo。</p>
<p>master 进程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handle = net._createServerHandle(<span class="string">'0.0.0.0'</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">   fork(<span class="string">'./worker'</span>).send(&#123;&#125;, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>worker 进程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m, handle</span>) </span>&#123;</span><br><span class="line">  start(handle);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="string">'hello nodejs'</span>;</span><br><span class="line"><span class="keyword">var</span> res = [<span class="string">'HTTP/1.1 200 OK'</span>,<span class="string">'content-length:'</span>+buf.length].join(<span class="string">'\r\n'</span>)+<span class="string">'\r\n\r\n'</span>+buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">server</span>) </span>&#123;</span><br><span class="line">    server.listen();</span><br><span class="line">    server.onconnection = <span class="function"><span class="keyword">function</span>(<span class="params">err,handle</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'got a connection on worker, pid = %d'</span>, process.pid);</span><br><span class="line">        <span class="keyword">var</span> socket = <span class="keyword">new</span> net.Socket(&#123;</span><br><span class="line">            handle: handle</span><br><span class="line">        &#125;);</span><br><span class="line">        socket.readable = socket.writable = <span class="literal">true</span>;</span><br><span class="line">        socket.end(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存后直接运行 <code>node  master.js</code> 启动服务器，在另一个终端多次运行 <code>ab -n10000 -c100  http://127.0.0.1:3000/</code></p>
<p>各个 worker 进程统计到的请求数分别为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker <span class="number">63999</span>  got <span class="number">14561</span> connections</span><br><span class="line">worker <span class="number">64000</span>  got <span class="number">8329</span>  connections</span><br><span class="line">worker <span class="number">64001</span>  got <span class="number">2356</span>  connections</span><br><span class="line">worker <span class="number">64002</span>  got <span class="number">4885</span>  connections</span><br></pre></td></tr></table></figure>
<p>相信到这里大家也应该知道这种多进程模型比较明显的问题了</p>
<ul>
<li>多个进程之间会竞争 accpet 一个连接，产生惊群现象，效率比较低。</li>
<li>由于无法控制一个新的连接由哪个进程来处理，必然导致各 worker 进程之间的负载非常不均衡。</li>
</ul>
<p>这其实就是著名的”惊群”现象。</p>
<p>简单说来，多线程/多进程等待同一个 socket 事件，当这个事件发生时，这些线程/进程被同时唤醒，就是惊群。可以想见，效率很低下，许多进程被内核重新调度唤醒，同时去响应这一个事件，当然只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠（也有其他选择）。这种性能浪费现象就是惊群。</p>
<p>惊群通常发生在 server 上，当父进程绑定一个端口监听 socket，然后 fork 出多个子进程，子进程们开始循环处理（比如 accept）这个 socket。每当用户发起一个 TCP 连接时，多个子进程同时被唤醒，然后其中一个子进程 accept 新连接成功，余者皆失败，重新休眠。</p>
<h3 id="nginx_proxy">nginx proxy</h3><p>现代的 web 服务器一般都会在应用服务器外面再添加一层负载均衡，比如目前使用最广泛的 nginx。<br>利用 nginx 强大的反向代理功能，可以启动多个独立的 node 进程，分别绑定不同的端口，最后由nginx 接收请求然后进行分配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123; </span><br><span class="line">  upstream cluster &#123; </span><br><span class="line">      server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3000</span>; </span><br><span class="line">      server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3001</span>; </span><br><span class="line">      server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3002</span>; </span><br><span class="line">      server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3003</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  server &#123; </span><br><span class="line">       listen <span class="number">80</span>; </span><br><span class="line">       server_name www.domain.com; </span><br><span class="line">       location / &#123; </span><br><span class="line">            proxy_pass http:<span class="comment">//cluster;</span></span><br><span class="line">       &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式就将负载均衡的任务完全交给了 nginx 处理，并且 nginx 本身也相当擅长。再加一个守护进程负责各个 node 进程的稳定性，这种方案也勉强行得通。但也有比较大的局限性，比如想增加或者减少一个进程时还得再去改下 nginx 的配置。该方案与 nginx 耦合度太高，实际项目中并不经常使用。</p>
<h2 id="小结">小结</h2><p>说了这么多，一直在讲解 Node.js 多进程部署时遇到的各种问题。小伙伴们肯定会有非常多的疑问。实际的 Node.js 项目中我们到底是如何利用多进程的呢，并且如何保障各个 worker 进程的稳定性。如何利用 cluster 模块 fork 子进程，父子进程间又是如何实现通信的呢？</p>
<p>下篇将为大家一一揭晓，敬请期待！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB17WhrKpXXXXXiXpXX2AXZ8pXX-900-500.png" alt="当我们谈论 cluster 时我们在谈论什么(上)"></p>
<p>Node.js 诞生之初就遭]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="cluster" scheme="http://taobaofed.org/tags/cluster/"/>
    
      <category term="多进程" scheme="http://taobaofed.org/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[已买到的宝贝前端组件化探索]]></title>
    <link href="http://taobaofed.org/blog/2015/11/02/buy-component/"/>
    <id>http://taobaofed.org/blog/2015/11/02/buy-component/</id>
    <published>2015-11-02T05:44:27.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1FYNoKpXXXXc_XpXXXXXXXXXX-900-500.jpg" alt="已买到的宝贝前端组件化探索"></p>
<p>随着已买到的宝贝组件化全网回归完成，项目开发工作终于告一段落了，接下来便是 Beta ，灰度发布。我也终于有了时间来总结一下整个项目。</p>
<p>同学们普遍对 PC 业务如何进行组件化感兴趣，在此就把我在项目中的思考过程，积累的经验写出来与大家分享。</p>
<p>先来介绍一下已买到的宝贝这个业务：</p>
<p><strong>已买到的宝贝是全网（淘宝／天猫）买家进行订单相关操作的平台（订单相关的操作如：取消订单，确认收货，订单搜索等），承载了全网业务的订单模型</strong> 。</p>
<ul>
<li>线上网址： <a href="https://trade.taobao.com/trade/itemlist/list_bought_items.htm" target="_blank" rel="external">https://trade.taobao.com/trade/itemlist/list_bought_items.htm</a></li>
<li>主要入口：淘宝／天猫吊顶</li>
</ul>
<h2 id="我们为什么要做组件化？">我们为什么要做组件化？</h2><h3 id="技术建模的需要">技术建模的需要</h3><p>在订单管理中，不同的业务订单在其生命周期中会有不同的状态和对应的操作，我们把这些订单生命周期进行抽象，得出订单模型。例如，基础的订单模型是这样的：</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1toR2JXXXXXX2XXXXH3beFXXX-1024-768.jpg" alt="基础订单模型"></p>
<p>普通的集市商品下单后其订单生命周期如上所示。但订单模型是可定制的，不同的业务会针对自己商品的特点对订单模型进行定制。例如大额商品的一种定制：预售二阶段订单模型是这样的：</p>
<p><img src="http://gtms03.alicdn.com/tps/i3/TB1eRdCJXXXXXXIapXXH3beFXXX-1024-768.jpg" alt="预售二阶段订单模型"></p>
<p>可以看到，它实际上是对基础订单模型的一种扩充。两种订单模型在实际产品（已买到的宝贝）的展示如下：</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1sWFVJXXXXXaYXpXXH3beFXXX-1024-768.jpg" alt="订单模型展示对比"></p>
<p>从 UI 层面来看，预售二阶段订单模型虽然看起来比基础订单模型复杂了不少，但两者是有共性的。预售的第二行和第三行的展示结构和内容形式与基础订单模型的第一行是一模一样的。实际上，哪怕再有新的业务接入，设计师也会遵循着这套设计规则：复用，扩充。</p>
<p>订单模型会随着业务的多样化而不断变更、增加。而我们原有的系统抽象能力是非常弱的，基本上把不同的业务订单模型都写一份，这样的开发效率十分低下，维护成本也非常高。</p>
<p>所以这时候产品的技术抽象建模就很有必要了。</p>
<p>我们发现，尽管业务千变万化，但是其 UI 是可抽象的，在前端上我们可以基于 UI 的抽象进行技术抽象。</p>
<p>在技术抽象上，一种思路就是，把具有相同布局结构和展示的业务逻辑抽象成前端组件，比方说上面的 SubOrder，SubOrder 既可以用于实现基础订单模型，也可以用于一些复杂的订单模型：例如预售二阶段订单模型，例如拍卖订单模型，例如婚纱摄影分阶段订单模型。</p>
<p><strong>利用组件化的抽象方式，有助于我们提高代码复用率，从而提高开发效率。</strong></p>
<h3 id="协作模式的变革">协作模式的变革</h3><p>然后是协作层面。协作分为2个方面：一个是我们系统内各个角色人员间的协作，另外一个方面是我们的开发人员和其他业务方开发人员间的协作。</p>
<p>先来看看前者，我们的现状是这样的：</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1wUREJXXXXXbBaXXXH3beFXXX-1024-768.jpg" alt="协作模式"></p>
<p>View 层是设计及前后端集体工作的结果，可以说是设计及前后端沟通的桥梁。它一方面是对设计的还原，另一方面赋予数据生命力。传统的 Java 应用把 View 层放在了应用项目里，例如 Webx 的 velocity。随着 Web 工业化的发展，前端工程师的出现，View 层的管理都交给了前端。但目前一些糟糕的问题是：</p>
<ol>
<li>职责界限模糊：在多人协作项目中，前后端对 VM 都有操作权限，并且 Webx 赋予 VM 的能力强大（例如可以直接调用 Java 类的方法），导致这个原本属于前端管理的范畴却失去了控制力。</li>
<li>Velocity 的学习成本高昂：这种模板语法并不在主流的前端知识体系内。可以在 View 层调用 Java 工具类，这也很难让前端开发人员产生好感。</li>
<li>View 层职能界限模糊：由于可以在 View 层调用 Java Model 层，不少后端开发人员对这种能力的滥用，导致业务逻辑和展现逻辑混淆在一起，越来越难以进行新业务的介入和系统的维护。</li>
</ol>
<p>无论如何，前端对 View 层管理权的回收是无可争议的了。但回收后怎样设计才能使得设计及前后端的协作更高效呢？</p>
<p>不卖关子，直接说结果。基于组件化的协作模式，它可以是这样的：</p>
<p><img src="https://img.alicdn.com/tps/TB108X8JXXXXXa1XpXXXXXXXXXX-1024-768.jpg" alt="基于组件化的协作模式"></p>
<p>因为组件化是基于 UI 的建模，由数据进行驱动。所以设计、前后端的沟通纬度都限定在了组件层面。这种更小的粒度的沟通纬度，集中化管理的方式，可以让协作成本更低。</p>
<p>除了应用人员的协作，因为订单业务是平台产品，所以我们的系统实际上还面临着和其他业务方进行协作问题。现有的协作模式是这样：</p>
<p><img src="https://img.alicdn.com/tps/TB1YPqcJXXXXXaaXXXXXXXXXXXX-1024-768.jpg" alt="业务协作模式"></p>
<p>可以看到，这种协作模式导致订单管理的前端开发人员频繁地成为了业务的最终实现者，这显然和我们产品对开发的定位是不一致的：</p>
<p><strong>订单管理平台化的产品特性要求我们技术需要提供一种平台化的方案，让外部业务方能够对自己的业务有定制权，同时我们还需要有能力去去管控这些权力。</strong></p>
<p>当组件化应用到我们系统中后，我们与业务方的协作模式将会是这样的：</p>
<p><img src="https://img.alicdn.com/tps/TB1KbdZJXXXXXcMXFXXXXXXXXXX-1024-768.jpg" alt="基于组件化的协作模式"></p>
<h2 id="我们的组件化是怎么做的？">我们的组件化是怎么做的？</h2><h3 id="组件的封装方式">组件的封装方式</h3><p>首先是为组件选择一种封装方式。也许你不知道，其实我们走了不少弯路。@紫英 @修名 @锂锌 @自寒 和 我曾经基于 KISSY实现了一套组件化方案，但最终我还是决定拥抱社区。我们知道目前流行的组件库有：Angular，Polymer，React。网上关于这三者的对比文章有很多，感兴趣的话可以看一下这几篇：</p>
<ul>
<li><a href="http://www.zhihu.com/question/26644904/answer/33634518" target="_blank" rel="external">2014 年末有哪些比较火的 Web 开发技术？</a></li>
<li><a href="https://github.com/xufei/blog/issues/19" target="_blank" rel="external">2015前端组件化框架之路–当下最时髦的前端组件化框架/库</a></li>
<li><a href="http://www.cnblogs.com/sskyy/p/4264371.html" target="_blank" rel="external">2015前端框架何去何从</a></li>
</ul>
<p>促使我们选择 React 的原因主要是下面四点：</p>
<ul>
<li><strong>兼容 IE8：</strong>在我们的业务中有20%左右的用户数，它非常重要，不可忽视</li>
<li><strong>专注于 View：</strong>很容易和公司内部已有的技术栈结合，而且的其配套技术方案比较成熟</li>
<li><strong>多 Targets</strong>： “React 让我们做到 Web 以外的 target。Virtual DOM 更像是 UI Virual Machine，自动帮你映射到真正的实现上。可以是 浏览器 DOM 、iOS UI、Android UI等”－－by <a href="https://github.com/dfguo/blog/issues/1" target="_blank" rel="external">Dafeng</a></li>
<li><strong>有服务器端渲染方案来加速首屏</strong></li>
</ul>
<h3 id="规划、开发组件">规划、开发组件</h3><h4 id="规划">规划</h4><p>所谓组件化，核心意义莫过于提取真正有复用价值的东西。那怎样的东西有复用价值呢？</p>
<ul>
<li>公共样式</li>
<li>控件</li>
<li>稳定的业务逻辑</li>
</ul>
<p>因此，我们会把组件进行分层，有三层：</p>
<p>第一层是公共样式部分，例如像以前的 <a href="http://baike.baidu.com/view/5186496.htm" target="_blank" rel="external">reset.css</a>。现在也会有这样的部分。我也将所有的标签进行了一些重置和默认赋值，把它们封装成 @ali/rc-trade-tag，调用方式如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> A = <span class="keyword">require</span>(<span class="string">'@ali/rc-trade-tag/lib/A'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &lt;A href=<span class="string">""</span>&gt;<span class="keyword">Link</span>&lt;/A&gt;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>再之上是通用组件，它们不带有任何的业务逻辑，只负责展示或者交互的抽象。这一层就类似于 <a href="http://react-bootstrap.github.io" target="_blank" rel="external">Bootstrap</a> 了。调用方式如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var <span class="constant">Dialog</span> = <span class="keyword">require</span>(<span class="string">'@ali/rc-trade-common/lib/Dialog'</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>...</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &lt;<span class="constant">Dialog</span></span><br><span class="line">            ref=<span class="string">'dialog'</span></span><br><span class="line">            visible=&#123;this.state.visible&#125;</span><br><span class="line">            onClose=&#123;this.handleClose&#125;</span><br><span class="line">            style=<span class="expansion">&#123;&#123;<span class="symbol">width:</span> <span class="number">360</span>&#125;&#125;</span></span><br><span class="line">        &gt;</span><br><span class="line">            test</span><br><span class="line">        &lt;<span class="regexp">/Dialog&gt;</span><br><span class="line">    &lt;/div</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/...</span></span><br></pre></td></tr></table></figure>
<p>最上层就是是业务组件，它是稳定的业务逻辑的抽象。它的意义在于，有些业务逻辑是在页面中或者我们整个应用中是通用的，复用性很高；另一方面，业务组件的抽象可以让不同的业务方自己去管理这些组件。</p>
<p>整个组件层的架构如下：</p>
<p><img src="http://gtms04.alicdn.com/tps/i4/TB1IPVYJXXXXXcYXXXXH3beFXXX-1024-768.jpg" alt="组件架构"></p>
<h4 id="样式">样式</h4><p>在组件的封装上，有一个问题是比较头疼的，就是样式的封装。</p>
<p>按照我们的设想，各组件应该是自我管理，自我约束，互相相不受影响的。但是如果用 CSS 来管理样式的话，就会有命名空间等问题（<a href="https://speakerdeck.com/vjeux/react-css-in-js" target="_blank" rel="external">React: CSS in JS</a>）。</p>
<p>一种做法是使用 <a href="https://facebook.github.io/react/tips/inline-styles.html" target="_blank" rel="external">Inline Styles</a>。但它不是万能的，它面临着另外一些问题，例如无法使用伪类选择器：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">    <span class="symbol">color:</span> blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="symbol">a:</span>hover&#123;</span><br><span class="line">    <span class="regexp">//</span>....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;a style=<span class="expansion">&#123;&#123;<span class="symbol">color:</span> <span class="string">'blue'</span>&#125;&#125;</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了能够使用伪类选择器，我在社区中狩猎到了 <a href="https://github.com/FormidableLabs/radium" target="_blank" rel="external">Radium</a> ，它可以让 Inline Style 的写法支持伪类选择器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">Radium</span> = require(<span class="symbol">'radiu</span>m');</span><br><span class="line"><span class="keyword">var</span> <span class="type">React</span> = require(<span class="symbol">'reac</span>t');</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Radium</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;button style=&#123;styles.base&#125;&gt;</span><br><span class="line">            &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;/button&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> styles = &#123;</span><br><span class="line">    base: &#123;</span><br><span class="line">        color: '#fff',</span><br><span class="line">        ':hover': &#123;</span><br><span class="line">            backgroundColor: '#<span class="number">0074</span>d9'</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们曾经在周会上讨论过这个库，认为它有三个问题：</p>
<ul>
<li>它是嵌入式的，对于我们而言是个黑盒</li>
<li>不支持 React Native：无法满足我们跨终端的需求</li>
<li>完全不兼容 IE8：实践证明浏览器兼容性不足，无法满足我们的产品需求</li>
</ul>
<p>最终我们还是回到了 Inline Style 的方式，那或许你会问 Browser state styles to support? Media queries? –  请看 <a href="https://github.com/js-next/react-style#not-supported-css-features" target="_blank" rel="external">Not supported CSS features</a> 中的观点。</p>
<h3 id="整体架构">整体架构</h3><p>解决了组件这个层面的问题后，还有几个问题需要我们思考：</p>
<ul>
<li>组件需要的数据从哪里来？</li>
<li>组件间如何进行通讯？</li>
<li>前后端如何进行通讯？</li>
</ul>
<h4 id="组件需要的数据从哪里来？">组件需要的数据从哪里来？</h4><p>业务组件是有业务逻辑的，我们应该如何处理呢？</p>
<p>比如说，性别选择的下拉框，它是一个非常通用化的功能，照理说是很适合被当做组件来提供的。但是究竟如何封装它，我们就有些犯难了。这个组件里除了界面，还有数据，这些数据应当内置在组件里吗？理论上从组件的封装性来说，是都应当在里面的，于是就这么造了一个组件：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;GenderSelect&gt;</span><span class="tag">&lt;/GenderSelect&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个组件非常美好，只需直接放在任意的界面中，就能显示带有性别数据的下拉框了。性别的数据很自然地是放在组件的实现内部，一个写死的数组中。这个例子太简单了，我们改一下，改成交易状态的下拉框。</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1gkFFJXXXXXXraXXXwQWjIXXX-247-312.png" alt="交易状态的下拉框"></p>
<p>表面上看，这个没什么区别。但是，交易状态是统一配置的，也就是说，这个数据来源于服务端。这时候，你是不是想把一个 HTTP 请求封装到这组件里？</p>
<p>这样做也不是不可以，但存在至少两个问题：</p>
<ul>
<li>如果这类组件在同一个界面中出现多次，就可能存在请求的浪费，因为有一个组件实例就会产生一个请求。</li>
<li>如果交易状态的配置界面与这个组件同时存在，当我们在配置界面中新增一个状态了，下拉框组件中的数据并不会实时刷新。</li>
</ul>
<p>第一个问题只是资源的浪费，第二个就是数据的不一致了。曾经在很多系统中，大家都是手动刷新当前页面来解决这问题的，但到了这个时代，人们都是追求体验的，在一个组件化的解决方案中，不应再出现此类问题。</p>
<p>如何解决这样的问题呢？那就是引入一层 Store 的概念，每个组件不直接去到服务端请求数据，而是到对应的前端数据缓存中去获取数据，让这个缓存自己去跟服务端保持同步。</p>
<h4 id="组件间如何进行通讯？">组件间如何进行通讯？</h4><p>前面的组件数据章节中，也有介绍到组件通讯的部分：交易状态配置和交易状态列表的显示，并谈到了我们的架构需要引入 Store 一层。</p>
<p>现在，我们已经决定通过 Store 来维持并统一管理状态，但是 Component 如何触发状态的变更并且最后更新视图呢？</p>
<p>也许你就可以下结论说，组件间的通讯就通过操作 Store 来同步就行了。但是在实际项目中，如果在 Component 层操作 Store ，会引起一些问题。比方说 Store 的读写权限无法控制。</p>
<p>在思考过程中，我有去看看社区中是否有相关的经验沉淀，于是注意到了 <a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux</a> 。为什么选择它，我觉得这篇文章讲得会比我好：<a href="http://www.infoq.com/cn/news/2014/05/facebook-mvc-flux" target="_blank" rel="external">Facebook：MVC不适合大规模应用，改用Flux</a></p>
<p>我们来看看实际中的应用：</p>
<p><img src="http://gtms03.alicdn.com/tps/i3/TB1hPRxJXXXXXayapXX6Oa5PXXX-929-401.png" alt="组件间通讯"></p>
<p>“全选”是业务组件 <code>OrdersOperate</code> 里面的一个操作，“单选”则在 <code>OrderHead</code> 业务组件内。如何在点击全选的时候把所有单选都勾上？</p>
<ul>
<li><p>首先，为 <code>OrderStore</code> 设置一个是否选中的状态：<code>_selected</code>（为什么是下划线开头？因为在 Store 中的数据都是从服务端获取的，字段名都是服务端给出，所有前端自定义的状态字段都会以下划线开头用以区分）：</p>
<p>  <img src="http://gtms04.alicdn.com/tps/i4/TB1Rw4NJXXXXXcdXFXXIWcvKVXX-264-51.png" alt="_selected"></p>
</li>
<li><p>然后 <code>OrderHead</code> 中的 input 通过读取 OrderStore 中的 <code>_selected</code> 来决定是否选中：</p>
<p>  <img src="http://gtms02.alicdn.com/tps/i2/TB1VTFNJXXXXXaYXFXXTG0wVpXX-495-81.png" alt=""><br>  <img src="http://gtms01.alicdn.com/tps/i1/TB1I_0RJXXXXXc3XpXXx.gV9XXX-832-29.png" alt=""></p>
</li>
<li><p><code>OrdersOperate</code> 中“全选”动作触发一个 action （canSelectOrderIds 中存储的是当前列表所有可进行选择的 OrderID）：</p>
<p>  <img src="http://gtms02.alicdn.com/tps/i2/TB1dcdLJXXXXXahXVXXWeLo8FXX-789-65.png" alt=""><br>  <img src="http://gtms02.alicdn.com/tps/i2/TB19wFUJXXXXXa0XpXXyr0w_pXX-847-67.png" alt=""></p>
</li>
<li><p><code>OrderStore</code> 中监听了这个 action ，根据传过来的 orderIds 和需要设置的值找出相关 Order 进行设置：</p>
<p>  <img src="http://gtms01.alicdn.com/tps/i1/TB1fFN3JXXXXXXgXXXXSxHCUXXX-506-70.png" alt=""></p>
</li>
</ul>
<p>由于 <code>OrderHead</code> 这个 Component 是通过读取 <code>OrderStore</code> 的数据来决定是否选中 input 的，所以 Store 的变化会触发 Component 的刷新。</p>
<p><strong>Flux 只是 Facebook 提出的一套模式思路，它并没有具体的实现。我们自己实现了一套 Flux 的 API ，命名为 Relax(@ali/relax)。</strong></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╔═════════╗       ╔════════╗       ╔═════════════════╗</span><br><span class="line">║ Actions ║──────&gt;║ Stores ║──────&gt;║ <span class="keyword">View</span> Components ║</span><br><span class="line">╚═════════╝       ╚════════╝       ╚═════════════════╝</span><br><span class="line">     ^                                      │</span><br><span class="line">     └──────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<h4 id="前后端如何进行通讯？">前后端如何进行通讯？</h4><p>接下来需要处理的则是前后端间的通讯问题。在没有进行组件化之前，页面上的所有操作都是同步的，组件化后为了提高用户体验，页面上的操作都改成异步的方式实现了，例如翻页、搜索、删除订单。</p>
<p>具体到删除订单这个异步操作，我们需要怎么做呢？</p>
<p><img src="http://gtms04.alicdn.com/tps/i4/TB1_JVFJXXXXXXhaXXXwxPi7VXX-1014-501.png" alt="删除订单"></p>
<p>我的做法是：继续沿用 Flux 模式，引入 IO 层。</p>
<p>Component 会发出一个删除的 action ，IO 中监听该 action 并请求 Server ，Server 如果成功则返回最新的列表数据给 IO，IO 再触发一个删除成功的 action 传入最新列表数据，OrderStore 监听删除成功 action ，拿到最新的列表数据，刷新 Component 。</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB13QJFJXXXXXaKaXXXH3beFXXX-1024-768.jpg" alt="flux2"></p>
<p>再来看看我们整个应用的架构，它就是这样：</p>
<p><img src="http://gtms01.alicdn.com/tps/i1/TB1Fg80JXXXXXXJXFXXH3beFXXX-1024-768.jpg" alt="架构"></p>
<h3 id="和老系统和平相处">和老系统和平相处</h3><p>一切看起来是一个闭环了，最后要解决的问题是如何和老系统和平相处？为什么会有这样的问题呢，因为我们的页面某些功能还是要依赖吊顶插件，还有一些功能需要使用一些第三方插件。比方说：旺旺点灯，比方说 TBC。</p>
<p>在已买到的宝贝中，和老系统打交道的内容有：</p>
<h4 id="吊顶插件">吊顶插件</h4><p>旺旺点灯：对于一个异步渲染的页面来说，点灯工作需要自己完成。</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/288c1d70489f1fb633be3cc7329863041e3ced9a" alt="旺旺点灯"></p>
<p>吊顶本身提供了 <code>TB.Global.use</code> 方法来调用插件，所以还是比较省心的。我们只需要找到合适的时机去调用它就行了。</p>
<p>对于我们的页面需要使用的旺旺点灯功能，只需要在列表渲染完成后以及列表刷新时调用一下吊顶插件即可。</p>
<p>正当我踌躇满志地：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TB.<span class="keyword">Global</span>.<span class="keyword">use</span>(<span class="string">'fn-webww'</span>, <span class="function"><span class="keyword">function</span><span class="params">(G, webww)</span> </span>&#123;</span><br><span class="line">    webww.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>发现并不 work 。后才知道这个模块并没有 exports 出来。再查看就知道自己需要曲线救国了：</p>
<ul>
<li><p>新建一个 plugin：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> time = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> webww = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_.isObject(<span class="built_in">window</span>.Light) &amp;&amp; _.isFunction(<span class="built_in">window</span>.Light.light))&#123;</span><br><span class="line">            <span class="built_in">window</span>.Light.light();</span><br><span class="line">            time = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">5</span>&gt;time)&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    webww.init();</span><br><span class="line"></span><br><span class="line">                    time++;</span><br><span class="line">                &#125;, <span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webww;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表渲染完成后及刷新时调用该 plugin:</p>
  <figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var webww = require('../plugins/webww')<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        webww.init()<span class="comment">;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        webww.init()<span class="comment">;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="TBC_插件">TBC 插件</h4><p>TBC分享：</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1aThVJXXXXXXoXFXXURNdFFXX-877-438.png" alt="TBC分享"></p>
<p>TBC 和原有的系统并不冲突，只需要直接使用 <code>@ali/kissy-loader</code>  的 <code>use</code> 方法调用即可。但是出于以下原因，我建议做一层封装：</p>
<ul>
<li>对系统屏蔽掉 KISSY loader 的细节</li>
<li>统一调用方式</li>
<li>Gallery 插件集中版本化管理</li>
<li>缓存</li>
</ul>
<p>实现的代码非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">var</span> RSVP = <span class="built_in">require</span>(<span class="string">'rsvp'</span>);</span><br><span class="line"><span class="keyword">var</span> loader = <span class="built_in">require</span>(<span class="string">'@ali/kissy-loader'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ROOT = <span class="string">'tbc'</span>;</span><br><span class="line"><span class="keyword">var</span> INDEX = <span class="string">'index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">    share: <span class="string">'2.0.3'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TBC = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getUrl = <span class="function"><span class="keyword">function</span>(<span class="params">name, index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [ROOT, name, config[name], index || INDEX].join(<span class="string">'/'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">name, index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RSVP.Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( ! TBC[name])&#123;</span><br><span class="line">            loader.use(getUrl(name, index), <span class="function"><span class="keyword">function</span>(<span class="params">S, O</span>)</span>&#123;</span><br><span class="line">                TBC[name] = O;</span><br><span class="line">                resolve(O);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(TBC[name]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    getPlugin: <span class="function"><span class="keyword">function</span>(<span class="params">name, index</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_.indexOf(_.keys(config), name)&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> getPlugin(name, index);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//@<span class="doctag">TODO:</span>log 记录该错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在调用端，使用方式如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> share = <span class="keyword">require</span>(<span class="string">'@ali/trade-util/lib/TBC'</span>).getPlugin(<span class="string">'share'</span>);</span><br><span class="line"></span><br><span class="line">share.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(share)</span><span class="comment">&#123;</span><br><span class="line">    share.init(self.props.param);</span><br><span class="line">&#125;</span>);</span></span><br></pre></td></tr></table></figure>
<h4 id="第三方插件">第三方插件</h4><p>问答机器人：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/37ba07f36a5d5bb53e49673852d2900ba7e4da80" alt="screenshot"></p>
<p>问答机器人是客满团队维护的一个 KISSY 插件，对于这类功能，业务方短时间内是无法将它切换到我们的组件化方案的，所以我们这一版我们需要自己处理它。</p>
<p>好在并不复杂，只需要在我们的页面渲染完成后调用一下该脚本即可：</p>
<ul>
<li><p>新建一个 plugin：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loader = <span class="built_in">require</span>(<span class="string">'@ali/kissy-loader'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    init()&#123;</span><br><span class="line">        loader.use(<span class="string">'tb/support/1.8.0/robot/js/kissy_robot_recommend'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">S, robot</span>) </span>&#123;</span><br><span class="line">            robot.init();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面渲染完成后调用：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> robot = <span class="built_in">require</span>(<span class="string">'../plugins/robot'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> App = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        robot.init();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多语言">多语言</h3><p><img src="http://img3.tbcdn.cn/L1/461/1/f96d8ee3c5aeeb8a92492bb478e11c90142bd977" alt="screenshot"></p>
<p>还有一个问题就是多语言，已买到的宝贝本身就是支持多语言的（多的是，你不知道的事～）。</p>
<p>关于多语言，我们的处理方式是这样的：</p>
<ul>
<li>服务端：通过用户地域 IP 的判断，决定显示哪种语言</li>
<li>数据：后端通过插件进行输出的翻译，最终输出给前端的数据就是特定的语言</li>
<li>前端：后端会在初始化数据中指定当前需要前端显示的语言类型，前端根据该字段设置前端应用语言</li>
</ul>
<p>具体到前端这边怎么实现：</p>
<ul>
<li>语言管理库：<code>@ali/trade-util/lib/i18n</code> （该工具由@锂锌 提供）</li>
<li><p>组件创建时，配置语言包：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> I18N = <span class="built_in">require</span>(<span class="string">'@ali/trade-util/lib/i18n'</span>);</span><br><span class="line"></span><br><span class="line">I18N.register(&#123;</span><br><span class="line">    <span class="string">'zh-CN'</span>: &#123;</span><br><span class="line">        <span class="string">'combinDo.note'</span>: <span class="string">'淘宝提醒您：'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'zh-TW'</span>: &#123;</span><br><span class="line">        <span class="string">'combinDo.note'</span>: <span class="string">'淘寶提醒您：'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">            &#123;I18N.t('combinDo.note')&#125;</span><br><span class="line"></span><br><span class="line">            .......</span><br><span class="line">        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用启动时，指定语言：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = [<span class="string">'zh-CN'</span>, <span class="string">'zh-TW'</span>];</span><br><span class="line"><span class="keyword">var</span> I18N = <span class="built_in">require</span>(<span class="string">'@ali/trade-util/lib/i18n'</span>);</span><br><span class="line"><span class="keyword">var</span> i18n = _.isString(<span class="built_in">window</span>.i18n) &amp;&amp; _.indexOf(langs, <span class="built_in">window</span>.i18n)&gt;-<span class="number">1</span> ? <span class="built_in">window</span>.i18n : langs[<span class="number">0</span>];</span><br><span class="line">I18N.lang(i18n);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="工程化">工程化</h3><p>完成了架构的部分，再上一层便是工程。感谢 DEF（淘宝前端集成开发环境） ，使用它可以轻松地搭建起任何一种架构模式的工程套件。基于 DEF 我产出了对应的插件：def-relax，它包含的功能有：</p>
<ul>
<li>脚手架：generator</li>
<li>本地开发：dev</li>
<li>代码校验：lint</li>
<li>构建打包：build</li>
<li>线上发布：publish</li>
</ul>
<p>该套件在这里就不继续展开。</p>
<p><strong>要说明的是，def-relax 是一个历史阶段性产物，它的出现是由于团队在 React 方向上工程套件的短缺。目前 @妙净 正在做一整套基于 CMD 的工程套件，未来我们项目也将转向使用团队规范化的工程套件。</strong></p>
<p>除了工程套件，在工程管理方面，我觉得还有一些事情是需要做的：</p>
<ul>
<li><p><strong>组件测试</strong></p>
<p>  未来所有接入交易平台的组件库都需要进行测试</p>
</li>
<li><p><strong>组件化数据协议</strong></p>
<p>  规范化，版本化管理</p>
</li>
<li><p><strong>组件化管理平台</strong></p>
<p>  所有组件库可视化管理，设计、前后端的协作平台</p>
</li>
</ul>
<h3 id="性能瓶颈">性能瓶颈</h3><p>然后再来谈谈项目中遇到的性能问题和解决办法。</p>
<p>第一个问题是，由于我们的组件的粒度非常细，组件嵌套非常深，vdom 的重渲计算量会非常的大。这一方面，可以通过 <a href="http://facebook.github.io/react/docs/pure-render-mixin.html" target="_blank" rel="external">PureRenderMixin</a> 来避免不必要的 vdom diff 。</p>
<p>第二个问题是，随着 Store 的数据变大，操作的复杂度在提高，安全性变低，每一次数据操作的成本变得异常昂贵。<a href="http://facebook.github.io/immutable-js/" target="_blank" rel="external">Immutable.js</a> 可以在一定程度上解决这个问题。</p>
<h2 id="了不起的一步">了不起的一步</h2><p>最后，我觉得这个项目很 awesome 的二点：</p>
<ul>
<li>可能是第一个在淘宝核心产品上使用 React ，探索前端组件化的</li>
<li>是的，我们拉响了不再支持 IE6、IE7 的号角</li>
</ul>
<p>回想起我刚到阿里时的躇踌满志，整理过过《淘宝订单管理前端的困境与未来》。这一念之间的想法，把它真正做出来竟然用了大半。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1FYNoKpXXXXc_XpXXXXXXXXXX-900-500.jpg" alt="已买到的宝贝前端组件化探索"></p>
<p>随着已买到的宝贝组件化全网回归完成，项目开发工作终于告一段落了]]>
    </summary>
    
      <category term="Flux" scheme="http://taobaofed.org/tags/Flux/"/>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="组件化" scheme="http://taobaofed.org/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[timer 的优化故事]]></title>
    <link href="http://taobaofed.org/blog/2015/10/30/nodejs-timer/"/>
    <id>http://taobaofed.org/blog/2015/10/30/nodejs-timer/</id>
    <published>2015-10-30T08:05:19.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB1meIvKXXXXXayXpXX2AXZ8pXX-900-500.png" alt="timer 的优化故事"></p>
<p>前段时间 Node.js 发布了新版本 4.0，其中涉及到一个更新比较多的模块，那就是下面要介绍的 timer 模块。</p>
<blockquote>
<p>timers: Improved timer performance from porting the 0.12 implementation, plus minor fixes (Jeremiah Senkpiel)#2540, (Julien Gilli)nodejs/node-v0.x-archive#8751nodejs/node-v0.x-archive#8905 </p>
</blockquote>
<p>之前也对 timer 模块有过比较多的研究，断断续续的看过这个模块在 github 上的一些改动，于是借着这次机会整理一下自己对 timer 模块的理解，和小伙伴们一起分享 timer 模块的优化过程。</p>
<h2 id="使用场景">使用场景</h2><p>也许你在使用 Node.js 开发项目时并没有使用到 timer 模块，诸如 setTimeout 以及 setInterval 和 setImediate 方法等等。但如果你开发的是 web 项目，那么你的项目中一定涉及到了 timer 模块。</p>
<p>细心的同学在平时的 http 接口开发调试中可能会注意到，每个 http 的 request header 里都有一个 <code>Connection:keep-alive</code> 标识，这是 http/1.1 开始引入的，表示客户端需要和服务端一直保持着 tcp 连接。当然了，这个连接不能就这么一直保持着，所以一般都会有一个超时时间，超过这个时间客户端还没有发送新的 http 请求，那么服务器就需要自动断开从而继续为其他客户端提供服务。</p>
<p>Node.js 提供的 http 服务器便是采用 timer 模块来满足这种请求，每一个新的连接到来构造出一个 socket 对象，便会调用 socket.setTimeout 设置一个定时器用于超时后自动断开连接。</p>
<h2 id="设计">设计</h2><p>在 Node.js 开发的 web 项目中，timer 模块的使用频率是非常高的，每一个新的连接到来都会设置它的超时时间，而且每个连接的超时时间都一样，在 http server 中默认是 2*60*1000ms。Node.js 使用 c++ 包裹的 Timer 对象来实现定时器功能，下面的代码示例了使用 Timer 对象来实现一个非常简单的定时器。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">Timer</span> = process.binding('timer_wrap').<span class="keyword">Timer</span>;</span><br><span class="line"><span class="keyword">const</span> kOnTimeout = <span class="keyword">Timer</span>.kOnTimeout | 0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySetTimeout = function (fn, ms) &#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">timer</span>  = new <span class="keyword">Timer</span>();</span><br><span class="line">	<span class="keyword">timer</span>.start(ms, 0);</span><br><span class="line">	<span class="keyword">timer</span>[kOnTimeout] = fn;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">timer</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myClearTimeout = function(<span class="keyword">timer</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">timer</span> &amp;&amp; <span class="keyword">timer</span>.<span class="keyword">close</span>) &#123;</span><br><span class="line">		<span class="keyword">timer</span>.<span class="keyword">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mySetTimeout(function() &#123;</span><br><span class="line">	console.<span class="literal">log</span>('timeout!');</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure>
<p>那我们是否就可以用上面实现的 mySetTimeout 来对每个 socket 进行超时操作呢</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySetTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;socket.close();&#125;,<span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>可以是可以，但是这样真的好吗？设想我们做的是一个非常棒的产品，每天好几百万上千万的用户，高峰期在 2*  60* 1000ms这段时间内会产生非常多的新连接，必然会创建非常多的 Timer 对象，这个开销还真不小！</p>
<p>Node.js 在设计之初就非常非常注重性能，所以像上面这种这么简单的方案必然是不能接受的。</p>
<p>实际上在这2分钟之内，Node.js 中的 timer 模块只会创建一个 Timer 对象，一个 Timer 对象如何来满足这么多连接的超时处理呢？</p>
<p>timer 模块会使用一个链表来保存所有超时时间相同的对象，每个对象中都会存储开始时间 _idleStart 以及超时时间 _idleTimeout。链表中第一个加入的对象一定会比后面加入的对象先超时，当第一个对象超时完成处理后，重新计算下一个对象是否已经到时或者还有多久到时，之前创建的 Timer 对象便会再次启动并设置新的超时时间，直到当链表上所有的对象都已经完成超时处理，此时便会关闭这个 Timer 对象。</p>
<p>通过这种巧妙的设计，使得一个 Timer 对象得到了最大的重用，从而极大的提升了 timer 模块的性能。这一场景其实在 libev 中已早有研究  <a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts" target="_blank" rel="external">http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts</a> </p>
<h2 id="实现">实现</h2><p>上面说到 timer 模块通过 c++ 提供的 Timer 对象，最终生成 setTimeout 以及 setInterval 等函数暴露给用户使用。那 Timer 对象是如何实现的呢，下面我们就来一探究竟。</p>
<h3 id="一个最底层的_timer">一个最底层的 timer</h3><p>熟悉 linux 网络编程的同学一定听说过 epoll 吧，</p>
<blockquote>
<p>epoll 是什么？按照 man 手册的说法：是为处理大批量句柄而作了改进的 poll。当然，这不是 2.6 内核才有的，它是在 2.5.44 内核中被引进的 (epoll(4) is a new API introduced in Linux kernel 2.5.44)，它几乎具备了之前所说的一切优点，被公认为 Linux2.6 下性能最好的多路 I/O 就绪通知方法。</p>
</blockquote>
<p>其中有这么一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>收集在 epoll 监控的事件中已经发送的事件。参数 events 是分配好的 epoll_event 结构体数组，epoll 将会把发生的事件赋值到 events 数组中（events 不可以是空指针，内核只负责把数据复制到这个 events 数组中，不会去帮助我们在用户态中分配内存）。maxevents 告之内核这个 events 有多大，这个 maxevents 的值不能大于创建 epoll_create() 时的 size，参数 timeout 是超时时间（毫秒，0 会立即返回，-1 将不确定，也有说法说是永久阻塞）。如果函数调用成功，返回对应 I/O 上已准备好的文件描述符数目，如返回 0 表示已超时。</p>
</blockquote>
<p>当我们监听一个 fd 上的事件时，可以设置等待事件发生的超时时间。利用这个特性便可以非常简单的实现一个定时器功能。</p>
<p>由于我使用的是 mac 系统，所以就用 kqueue 来代替 epoll(它们之间非常相似,具体的详细介绍以及使用方法感兴趣的可以自行查阅相关资料)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/event.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENT_COUNT = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> timeval t_start,t_end;</span><br><span class="line">  <span class="keyword">int</span> fd = -<span class="number">1</span>;<span class="comment">//构造一个不会有任何事件发生的fd</span></span><br><span class="line">  <span class="keyword">int</span> kq = kqueue();</span><br><span class="line">  <span class="keyword">struct</span> kevent changes[<span class="number">1</span>];</span><br><span class="line">  EV_SET(&amp;changes[<span class="number">0</span>], fd, EVFILT_READ, EV_ADD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">int</span> timeout = <span class="number">3500</span>;</span><br><span class="line">  <span class="keyword">struct</span> kevent events[MAX_EVENT_COUNT];</span><br><span class="line">  <span class="keyword">struct</span> timespec spec;</span><br><span class="line">  spec.tv_sec = timeout / <span class="number">1000</span>;</span><br><span class="line">  spec.tv_nsec = (timeout % <span class="number">1000</span>) * <span class="number">1000000</span>;</span><br><span class="line">  gettimeofday(&amp;t_start, <span class="literal">NULL</span>);</span><br><span class="line">  kevent(kq, <span class="literal">NULL</span>, <span class="number">0</span>, events, MAX_EVENT_COUNT, &amp;spec);</span><br><span class="line">  gettimeofday(&amp;t_end, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"timeout = %d, run time is %ld\n"</span>, timeout,  t_end.tv_sec*<span class="number">1000</span>+t_end.tv_usec/<span class="number">1000</span> - (t_start.tv_sec*<span class="number">1000</span>+t_start.tv_usec/<span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们便利用 kqueue 实现了一个非常简单非常底层的定时器。</p>
<h3 id="libuv_中的_timer">libuv 中的 timer</h3><p>前面讲到，在 http server 中每一个新的连接并不会真的就去创建一个 Timer 对象。同样，在 Node.js 底层的定时器中，并不会每次创建一个 Timer 对象就在 kqueue 上注册一个事件等待超时。优化的思路和 Node.js 中的 timer 模块很相似，只不过现在不能保证每个定时器的超时时间都一样。</p>
<p>定时器有一个非常显著的特征，超时时间最短的定时器一定最先触发，假设我们有很多的定时任务，每个任务的执行时间都不同。当第一个定时器超时后，便从这些任务中查找出已经到点的任务并执行对应的超时处理，然后再重新计算余下任务中最先执行的时间，并根据这个时间再次开启一个定时器。</p>
<p>对应的算法需求就是每次都需要查找集合中最小的元素，显然二叉堆中的最小堆(父结点的键值总是小于或等于任何一个子节点的键值)是最适合不过的一种数据结构了。由于最小的元素总是处于根节点，我们可以以 O(1) 时间找到最小值。对于插入操作，在最坏的情况下，新插入的节点需要不断的和它的父节点进行交换，直到它为根节点为止。假设堆的高度为 h, 二叉树最多有 2^(h+1) - 1 个 节点. 因此新插入一个节点最多需要 log(n+1) -1 次比较，其算法复杂度为 O(logn)。</p>
<p><img src="http://gtms02.alicdn.com/tps/i2/TB1r0H9JpXXXXXaXpXXDezOOXXX-2004-1220.png" alt="http://gtms02.alicdn.com/tps/i2/TB1r0H9JpXXXXXaXpXXDezOOXXX-2004-1220.png"></p>
<p>libuv 中已经实现了一个最小二叉堆的算法 <a href="https://github.com/joyent/libuv/blob/master/src/heap-inl.h" target="_blank" rel="external">https://github.com/joyent/libuv/blob/master/src/heap-inl.h</a>, 下面我们就用这个算法来实现一个支持设置不同超时时间的定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/event.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//https://github.com/joyent/libuv/blob/master/src/heap-inl.h</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"heap-inl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> container_of(ptr, type, member) \</span><br><span class="line">  ((type *) ((char *) (ptr) - offsetof(type, member)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENT_COUNT = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> heap_node* heap_node[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;<span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">less_than</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> heap_node* ha, <span class="keyword">const</span> <span class="keyword">struct</span> heap_node* hb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">node_t</span>* a;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">node_t</span>* b;</span><br><span class="line"></span><br><span class="line">    a = container_of(ha, <span class="keyword">const</span> <span class="keyword">node_t</span>, heap_node);</span><br><span class="line">    b = container_of(hb, <span class="keyword">const</span> <span class="keyword">node_t</span>, heap_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;value &lt; b-&gt;value)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> heap *heap_p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">  heap_init(heap_p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">node_t</span> *node_p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">node_t</span>));</span><br><span class="line">    node_p-&gt;value = a[i]*<span class="number">1000</span>;</span><br><span class="line">    heap_insert(heap_p, (<span class="keyword">struct</span> heap_node*)node_p-&gt;heap_node, less_than);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> fd = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> kq = kqueue();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> kevent changes[<span class="number">1</span>];</span><br><span class="line">  EV_SET(&amp;changes[<span class="number">0</span>], fd, EVFILT_READ, EV_ADD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> kevent events[MAX_EVENT_COUNT];</span><br><span class="line">  <span class="keyword">struct</span> timeval t_start,t_end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(heap_p-&gt;nelts) &#123;</span><br><span class="line">      <span class="keyword">node_t</span> *node_p = container_of(heap_p-&gt;min, <span class="keyword">node_t</span>, heap_node);</span><br><span class="line">      <span class="keyword">struct</span> timespec spec;</span><br><span class="line">      spec.tv_sec = node_p-&gt;value / <span class="number">1000</span>;</span><br><span class="line">      spec.tv_nsec = (node_p-&gt;value % <span class="number">1000</span>) * <span class="number">1000000</span>;</span><br><span class="line">      gettimeofday(&amp;t_start, <span class="literal">NULL</span>);</span><br><span class="line">      kevent(kq, <span class="literal">NULL</span>, <span class="number">0</span>, events, MAX_EVENT_COUNT, &amp;spec);</span><br><span class="line">      gettimeofday(&amp;t_end, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"timeout = %d, run time is %ld\n"</span>, node_p-&gt;value,  t_end.tv_sec*<span class="number">1000</span>+t_end.tv_usec/<span class="number">1000</span> - (t_start.tv_sec*<span class="number">1000</span>+t_start.tv_usec/<span class="number">1000</span>));</span><br><span class="line">      heap_dequeue(heap_p, less_than);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"timer is over!\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 gcc timer.c -o timer &amp;&amp; ./timer 后输出</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">timeout</span> = <span class="number">2000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">2004</span></span><br><span class="line"><span class="keyword">timeout</span> = <span class="number">3000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">timeout</span> = <span class="number">4000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">4003</span></span><br><span class="line"><span class="keyword">timeout</span> = <span class="number">5000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">5005</span></span><br><span class="line"><span class="keyword">timeout</span> = <span class="number">6000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">6005</span></span><br><span class="line"><span class="keyword">timeout</span> = <span class="number">7000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">7005</span></span><br><span class="line"><span class="keyword">timeout</span> = <span class="number">8000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">8004</span></span><br><span class="line"><span class="keyword">timeout</span> = <span class="number">9000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">9000</span></span><br><span class="line"><span class="keyword">timeout</span> = <span class="number">10000</span>, <span class="command">run</span> <span class="property">time</span> <span class="keyword">is</span> <span class="number">10005</span></span><br><span class="line">timer <span class="keyword">is</span> <span class="keyword">over</span>!</span><br></pre></td></tr></table></figure>
<p>可以看到我们设置的 9 个定时器都预期执行了，除了有 5ms 以内的偏差。这就是 Node.js 中最底层的定时器实现了。</p>
<h3 id="nodejs_中的_timer">nodejs 中的 timer</h3><p>我们再回到 Node.js 中的 timer 模块，为了不影响到 Node.js 中的 event loop，timer 模块专门提供了一些内部的 api(timers._unrefActive) 给像 socket 这样的对象使用。</p>
<p>timer 内部会维护一个 unrefList 链表以及一个 unrefTimer Timer 对象，当有新的超时任务到来时便会添加到 unrefList 中，超时后便从 unrefList 中取出任务执行。</p>
<p>在最初的设计中，每次执行 _unrefActive 添加任务时都会维持着 unrefList 的顺序，保证超时时间最小的处于前面。这样在定时器超时后便可以以最快的速度处理超时任务并设置下一个定时器，但是在添加任务时最坏的情况下需要遍历 unrefList 链表中的所有节点。具体实现可参考<a href="https://github.com/nodejs/node/blob/5abd4ac079b390467360d671a186a061b5aba736/lib/timers.js" target="_blank" rel="external">https://github.com/nodejs/node/blob/5abd4ac079b390467360d671a186a061b5aba736/lib/timers.js</a></p>
<p>很显然，在 web 开发中建立连接是最频繁的操作，那么向 unrefList 链表中添加节点也就非常频繁了，而且最开始设置的定时器其实最后真正会超时的非常少，因为中间涉及到 io 的正常操作时便会取消定时器。所以问题就变成最耗性能的操作非常频繁，而几乎不花时间的操作却很少被执行到。</p>
<p>针对这种情况，如何解决呢？目前在node社区主要有2种方案。</p>
<h3 id="使用不排序的链表">使用不排序的链表</h3><p>主要思路就是将对 unrefList 链表的遍历操作，移到unrefTimeout定时器超时处理中。这样每次查找出已经超时的任务就需要花比较多的时间了 O(n)，但是插入操作却变得非常简单 O(1)，而插入节点正是最频繁的操作。</p>
<h3 id="使用二叉堆">使用二叉堆</h3><p>原理和 libuv 中的 timer 实现一样，添加和查找一个节点都能达到 O(log(n)) 的复杂度(找出最小节点本身很快，但是删除它需要 O(log(n)) 的复杂度)，能够在二者之间保持一个很好的平衡。</p>
<h3 id="benchamark">benchamark</h3><p>这2种方案都有比较详细 benchamark 数据， 具体可参考<a href="https://github.com/nodejs/node-v0.x-archive/wiki/Optimizing-_unrefActive" target="_blank" rel="external">https://github.com/nodejs/node-v0.x-archive/wiki/Optimizing-_unrefActive</a>。</p>
<h2 id="小结">小结</h2><p>在高并发连接到来并且很少有实际的超时事件发生时 unrefList 使用没有排序的链表来存储超时任务时性能是非常棒的。但是一旦出现很多超时事件都发生的情况下，对超时事件的处理会再次变成一个瓶颈。</p>
<p>而使用二叉堆来存储超时任务时，当有大量超时事件发生时性能会比链表好很多，没有超时事件触发时性能比链表稍差。</p>
<p>可见 Node.js 在不同的场景中使用的定时器实现也不都一样，说 Node.js 对性能的追求达到极致一点也不为过。当我们自己在实际的开发时，如果需要使用到定时器功能，不妨好好思考下哪种方案更适合业务场景，能够最大的提升 timer 模块的性能。</p>
<h2 id="参考文档">参考文档</h2><ul>
<li><a href="http://blog.chinaunix.net/uid-28304615-id-3579872.html" target="_blank" rel="external">HTTP Keep Alive分析与优化总结</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/aix/library/1105_huangrg_kqueue/" target="_blank" rel="external">使用 kqueue 在 FreeBSD 上开发高性能应用服务器</a></li>
<li><a href="https://github.com/nodejs/node/blob/master/lib/timers.js" target="_blank" rel="external">https://github.com/nodejs/node/blob/master/lib/timers.js</a></li>
<li><a href="https://github.com/nodejs/node/commit/e5bb66886bfa40818de7a96e982c5964eef9eb78" target="_blank" rel="external">https://github.com/nodejs/node/commit/e5bb66886bfa40818de7a96e982c5964eef9eb78</a></li>
<li><a href="https://github.com/nodejs/node-v0.x-archive/wiki/Optimizing-_unrefActive" target="_blank" rel="external">https://github.com/nodejs/node-v0.x-archive/wiki/Optimizing-_unrefActive</a></li>
<li><a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts" target="_blank" rel="external">http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts</a></li>
<li><a href="http://courses.cs.washington.edu/courses/cse373/06sp/handouts/lecture10.pdf" target="_blank" rel="external">binary heap</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB1meIvKXXXXXayXpXX2AXZ8pXX-900-500.png" alt="timer 的优化故事"></p>
<p>前段时间 Node.js 发布了新版本 4.0，其中涉及]]>
    </summary>
    
      <category term="nodejs" scheme="http://taobaofed.org/tags/nodejs/"/>
    
      <category term="timer" scheme="http://taobaofed.org/tags/timer/"/>
    
      <category term="优化" scheme="http://taobaofed.org/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 探秘（一）- 初识单线程的 Node.js]]></title>
    <link href="http://taobaofed.org/blog/2015/10/29/deep-into-node-1/"/>
    <id>http://taobaofed.org/blog/2015/10/29/deep-into-node-1/</id>
    <published>2015-10-29T07:44:30.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB1v9UnKXXXXXc5XXXXXXXXXXXX-900-500.png" alt="Node.js 探秘（一）- 初识单线程的 Node.js"></p>
<h2 id="前言">前言</h2><p>从Node.js进入人们的视野时，我们所知道的它就由这些关键字组成 <strong>事件驱动、非阻塞I/O、高效、轻量</strong>，它在官网中也是这么描述自己的。</p>
<blockquote>
<p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an <strong>event-driven</strong>, <strong>non-blocking I/O model</strong> that makes it <strong>lightweight</strong> and <strong>efficient</strong>.</p>
</blockquote>
<p>于是，会有下面的场景出现：</p>
<p>当我们刚开始接触它时，可能会好奇：</p>
<ul>
<li><strong>为什么在浏览器中运行的 Javascript 能与操作系统进行如此底层的交互？</strong></li>
</ul>
<p>当我们在用它进行文件 I/O 和网络 I/O 的时候，发现方法都需要传入回调，是异步的：</p>
<ul>
<li><strong>那么这种异步，非阻塞的 I/O 是如何实现的？</strong></li>
</ul>
<p>当我们习惯了用回调来处理 I/O，发现当需要顺序处理时，Callback Hell 出现了，于是有想到了同步的方法：</p>
<ul>
<li><strong>那么在异步为主的 Node.js，有同步的方法嘛？</strong></li>
</ul>
<p>身为一个前端，你在使用时，发现它的异步处理是基于事件的，跟前端很相似：</p>
<ul>
<li><strong>那么它如何实现的这种事件驱动的处理方式呢？</strong></li>
</ul>
<p>当我们慢慢写的多了，处理了大量 I/O 请求的时候，你会想：</p>
<ul>
<li><strong>Node.js 异步非阻塞的 I/O 就不会有瓶颈出现吗？</strong></li>
</ul>
<p>之后你还会想：</p>
<ul>
<li><strong>Node.js 这么厉害，难道没有它不适合的事情吗？</strong></li>
</ul>
<p>等等。。。</p>
<p>看到这些问题，是否有点头大，别急，带着这些问题我们来慢慢看这篇文章。</p>
<h2 id="Node-js_结构">Node.js 结构</h2><p>上面的问题，都挺底层的，所以我们从 Node.js 本身入手，先来看看 Node.js 的结构。</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/a9e67142615f49863438cc0086b594e48984d1c9" alt="Node.js Architecture"></p>
<p>我们可以看到，Node.js 的结构大致分为三个层次：</p>
<ul>
<li>Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 <a href="https://github.com/nodejs/node/tree/master/lib" target="_blank" rel="external">lib</a> 目录下可以看到。</li>
<li>Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 <a href="https://github.com/nodejs/node/blob/master/src/node.cc" target="_blank" rel="external">node.cc</a></li>
<li>这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。<ul>
<li>V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。</li>
<li>Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。</li>
<li>C-ares：提供了异步处理 DNS 相关的能力。</li>
<li>http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。</li>
</ul>
</li>
</ul>
<h2 id="Libuv">Libuv</h2><p>Libuv 是 Node.js 关键的一个组成部分，它为上层的 Node.js 提供了统一的 API 调用，使其不用考虑平台差距，隐藏了底层实现。</p>
<p>具体它能做什么，官网的这张图体现的很好：</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/cdd725280cce7929c5dd526bbf19e9de36591e09" alt="libuv_architecture"></p>
<p>可以看出，它是一个对开发者友好的工具集，包含定时器，非阻塞的网络 I/O，异步文件系统访问，子进程等功能。它封装了 Libev、Libeio 以及 IOCP，保证了跨平台的通用性。</p>
<p>我们只要先知道它本身是异步和事件驱动的，记住这点，下面的问题就有了答案，我们一一来看。</p>
<h2 id="与操作系统交互">与操作系统交互</h2><p>举个简单的例子，我们想要打开一个文件，并进行一些操作，可以写下面这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.open(<span class="string">'./test.txt'</span>, <span class="string">"w"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//..do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码的调用过程大致可描述为：<a href="https://github.com/nodejs/node/blob/master/lib/fs.js" target="_blank" rel="external">lib/fs.js</a> → <a href="https://github.com/nodejs/node/blob/master/src/node_file.cc" target="_blank" rel="external">src/node_file.cc</a> → <a href="https://github.com/nodejs/node/tree/master/deps/uv/src" target="_blank" rel="external">uv_fs</a></p>
<p>Node.js 深入浅出上的一幅图：</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/fad8e5f6433ca965b3fcf282910ba5bc3bff65cf" alt="Node.js File操作"></p>
<p>具体来说，当我们调用 <code>fs.open</code> 时，Node.js 通过 <code>process.binding</code> 调用 C/C++ 层面的 <code>Open</code> 函数，然后通过它调用 Libuv 中的具体方法 <code>uv_fs_open</code>，最后执行的结果通过回调的方式传回，完成流程。在图中，可以看到平台判断的流程，需要说明的是，这一步是在编译的时候已经决定好的，并不是在运行时中。</p>
<p>总体来说，我们在 Javascript 中调用的方法，最终都会通过 <code>process.binding</code> 传递到 C/C++ 层面，最终由他们来执行真正的操作。Node.js 即这样与操作系统进行互动。</p>
<p>通过这个过程，我们可以发现，实际上，Node.js 虽然说是用的 Javascript，但只是在开发时使用 Javascript 的语法来编写程序。真正的执行过程还是由 V8 将 Javascript 解释，然后由 C/C++ 来执行真正的系统调用，所以并不需要过分担心 Javascript 执行效率的问题。可以看出，Node.js 并不是一门语言，而是一个 <strong>平台</strong>，这点一定要分清楚。</p>
<h2 id="异步、非阻塞_I/O">异步、非阻塞 I/O</h2><p>通过上文，我们了解到，真正执行系统调用的其实是 Libuv。之前我们提到，Libuv 本身就是异步和事件驱动的，所以，当我们将 I/O 操作的请求传达给 Libuv 之后，Libuv 开启线程来执行这次 I/O 调用，并在执行完成后，传回给 Javascript 进行后续处理。</p>
<p>这里面的 I/O 包括文件 I/O 和 网络 I/O。两者的底层执行略有不同。从上面的 Libuv 官网的图中，我们可以看到，文件 I/O，DNS 等操作，都是依托线程池（Thread Pool）来实现的。而网络 I/O 这一大类，包括：TCP、UDP、TTY 等，是由 epoll、IOCP、kqueue 来具体实现的。</p>
<p>总结来说，一个异步 I/O 的大致流程如下：</p>
<ul>
<li><p>发起 I/O 调用</p>
<ol>
<li>用户通过 Javascript 代码调用 Node 核心模块，将参数和回调函数传入到核心模块；</li>
<li>Node 核心模块会将传入的参数和回调函数封装成一个请求对象；</li>
<li>将这个请求对象推入到 I/O 线程池等待执行；</li>
<li>Javascript 发起的异步调用结束，Javascript 线程继续执行后续操作。</li>
</ol>
</li>
<li><p>执行回调</p>
<ol>
<li>I/O 操作完成后，会将结果储存到请求对象的 result 属性上，并发出操作完成的通知；</li>
<li>每次事件循环时会检查是否有完成的 I/O 操作，如果有就将请求对象加入到 I/O 观察者队列中，之后当做事件处理；</li>
<li>处理 I/O 观察者事件时，会取出之前封装在请求对象中的回调函数，执行这个回调函数，并将 result 当参数，以完成 Javascript 回调的目的。</li>
</ol>
</li>
</ul>
<p><img src="http://img2.tbcdn.cn/L1/461/1/6a9490a6529010804899437ad63645233356d6bb" alt="Node.js 异步"></p>
<p>这里面涉及到了 Libuv 本身的一个设计理念，事件循环（Event Loop），它是一个类似于 <code>while true</code> 的无限循环，其核心函数是 <code>uv_run</code>，下文会用到。</p>
<p>从这里，我们可以看到，我们其实对 Node.js 的单线程一直有个误会。事实上，它的单线程指的是自身 Javascript 运行环境的单线程，Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作，还是通过 Libuv 以及它的事件循环来执行的。这也就是为什么 Javascript 一个单线程的语言，能在 Node.js 里面实现异步操作的原因，两者并不冲突。</p>
<h2 id="事件驱动">事件驱动</h2><p>说到，事件驱动，对于前端来说，并不陌生。事件，是一个在 GUI 开发时很常用的一个概念，常见的有鼠标事件，键盘事件等等。在异步的多种实现中，事件是一种比较容易理解和实现的方式。</p>
<p>说到事件，一定会想到回调，当我们写了一大堆事件处理函数后，Libuv 如何来执行这些回调呢？这就提到了我们之前说到的 <code>uv_run</code>，先看一张它的执行流程图：</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/b1d06a5e6d9965267cbddc95219a325e85b3ad2b" alt="uv_run 流程图"></p>
<p>在 <code>uv_run</code> 函数中，会维护一系列的监视器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_loop_s <span class="keyword">uv_loop_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_err_s <span class="keyword">uv_err_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_handle_s <span class="keyword">uv_handle_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_stream_s <span class="keyword">uv_stream_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_tcp_s <span class="keyword">uv_tcp_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_udp_s <span class="keyword">uv_udp_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_pipe_s <span class="keyword">uv_pipe_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_tty_s <span class="keyword">uv_tty_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_poll_s <span class="keyword">uv_poll_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_timer_s <span class="keyword">uv_timer_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_prepare_s <span class="keyword">uv_prepare_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_check_s <span class="keyword">uv_check_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_idle_s <span class="keyword">uv_idle_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_async_s <span class="keyword">uv_async_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_process_s <span class="keyword">uv_process_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_fs_event_s <span class="keyword">uv_fs_event_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_fs_poll_s <span class="keyword">uv_fs_poll_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> uv_signal_s <span class="keyword">uv_signal_t</span>;</span><br></pre></td></tr></table></figure>
<p>这些监视器都有对应着一种异步操作，它们通过 <code>uv_TYPE_start</code>，来注册事件监听以及相应的回调。</p>
<p>在 <code>uv_run</code> 执行过程中，它会不断的检查这些队列中是或有 <code>pending</code> 状态的事件，有则触发，而且它在这里只会执行一个回调，避免在多个回调调用时发生竞争关系，因为 Javascript 是单线程的，无法处理这种情况。</p>
<p>上面的图中，对 I/O 操作的事件驱动，表达的比较清楚。除了我们常提到的 I/O 操作，图中还表述了一种情况，timer（定时器）。它与其他两者不同之处在于，它没有单独开立新的线程，而是在事件循环中直接完成的。</p>
<p>事件循环除了维护那些观察者队列，还维护了一个 <code>time</code> 字段，在初始化时会被赋值为0，每次循环都会更新这个值。所有与时间相关的操作，都会和这个值进行比较，来决定是否执行。</p>
<p>在图中，与 timer 相关的过程如下：</p>
<ol>
<li>更新当前循环的 time 字段，即当前循环下的“现在”；</li>
<li>检查循环中是否还有需要处理的任务（handlers/requests），如果没有就不必循环了，即是否 alive。</li>
<li>检查注册过的 timer，如果某一个 timer 中指定的时间落后于当前时间了，说明该 timer 已到期，于是执行其对应的回调函数；</li>
<li>执行一次 I/O polling（即阻塞住线程，等待 I/O 事件发生），如果在下一个 timer 到期时还没有任何 I/O 完成，则停止等待，执行下一个 timer 的回调。如果发生了 I/O 事件，则执行对应的回调；由于执行回调的时间里可能又有 timer 到期了，这里要再次检查 timer 并执行回调。</li>
</ol>
<p>Node.js 会一直调用 <code>uv_run</code> 直到到循环不在 alive。</p>
<h2 id="同步方法">同步方法</h2><p>虽然 Node.js 是以异步为主要模式的，但我们在实际开发中，难免会有一些情况是有时序性的，如果由异步来写，就会写出很丑的 Callback Hell，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.query(<span class="string">'select nickname from users where id="12"'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	db.query(<span class="string">'select * from xxx where id="12"'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		db.query(<span class="string">'select * from xxx where id="12"'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			db.query(<span class="string">'select * from xxx where id="12"'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="comment">//...	</span></span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个时候如果有同步方法，就会方便很多。这一点，Node.js 的开发者也想到了，目前大部分的异步操作函数，都存在其对应的同步版本，只需要在其名称后面加上 <code>Sync</code> 即可，不用传入回调。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = fs.readFileSync(<span class="string">'/test.txt'</span>, &#123;<span class="string">"encoding"</span>: <span class="string">"utf-8&#125;);</span></span><br></pre></td></tr></table></figure>
<p>这写方法还是比较好用的，执行 shell 命令，读取文件等都比较方便。不过，体验不太好的一点就是这种调用的错误收集，它不会像回调函数那样，在第一参数中传入错误信息，它会将错误直接抛出，你需要使用 <code>try...catch</code> 来获取，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  data = fs.readFileSync(<span class="string">'/test.txt'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">	<span class="keyword">if</span> (e.code == <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这些方法如何实现的，我们下回再论。</p>
<h2 id="一些可能的瓶颈">一些可能的瓶颈</h2><p>这里只见到讨论下自己的理解，欢迎指正。</p>
<p>首先，文件的 I/O 方面，用户代码的运行，事件循环的通知等，是通过 Libuv 维护的线程池来进行操作的，它会运行全部的文件系统操作。既然这样，我们抛开硬盘的影响，对于严谨的 C/C++ 来说，这个线程池一定是有大小限制的。官方默认给出的大小是 <strong>4</strong>。当然是可以改变的。在启动时，通过设置 <code>UV_THREADPOOL_SIZE</code> 来改变这个值即可。不过，最大也只能是 <strong>128</strong>，因为这个是涉及到内存占用的。</p>
<p>这个线程池对于所有的事件循环是共享的。当一个函数要使用线程池的时候（比如调用 <code>uv_queue_work</code>），Libuv 会预先分配并初始化 <code>UV_THREADPOOL_SIZE</code> 所允许的线程出来。而  <strong>128</strong> 占用的内存大约是 1MB，如果设置的太高，当使用线程池频繁时，会因为内存占用过多而降低线程的性能。<a href="https://github.com/libuv/libuv/blob/master/docs/src/threadpool.rst" target="_blank" rel="external">具体说明</a>;</p>
<p>对于网络 I/O 方面，以 Linux 系统下来说，网络 I/O 采用的是 epoll 这个异步模型。它的优点是采用了事件回调的方式，大大降低了文件描述符的创建（Linux下什么都是文件）。</p>
<p>在每次调用 <code>epoll_wait</code> 时，实际返回的是就绪描述符的数量，根据这个值，去 epoll 指定的数组里面取对应数量的描述符，是一种 <strong>内存映射</strong> 的方式，减少了文件描述符的复制开销。</p>
<p>上面提到的 epoll 指定的数组，它的大小即可监听的数量大小，它在不同的系统下，有不同的默认值，可见这里 <a href="https://github.com/nodejs/node/blob/master/deps/uv/src/unix/linux-syscalls.c#L80" target="_blank" rel="external">epoll create</a>。</p>
<p>有了大小的限制，还远不够，为了保证运行的稳定，防止你在调用 epoll 函数时，指针越界，导致内存泄漏。还会用到另外一个值 <code>maxevents</code>，它是 <code>epoll_wait</code> 所能处理的最大数量，在调用 <code>epoll_wait</code> 时可以指定。一般情况下小于创建时（epoll_create）的数组大小，当然，也可以设置的比 size 大，不过应该没什么用。可以想到如果就绪的事件很多，超过了 <code>maxevents</code>，那么超出的事件就要等待前面的事件处理完成，才可以继续，可能会导致效率的下降。</p>
<p>在这种情况下，你可能会担心事件会丢失。其实，是不会丢失的，它会通过 <code>ep_collect_ready_items</code> 将这些事件保存在一个队列中，在下一个 <code>epoll_wait</code> 再进行通知。</p>
<h2 id="Node-js_不适合做什么">Node.js 不适合做什么</h2><p>虽然看起来，Node.js 可以做很多事情，并且拥有很高的性能。比如做聊天室，搭建 Blog 等等，这些 I/O 密集型的应用，是比较适合 Node.js 的。</p>
<p>但是，有一种类型的应用，可能 Node.js 处理起来会比较吃力，那就是 CPU 密集型的应用。前文提到，Libuv 通过事件循环来处理异步的事件，这是存在于 Node.js 主线程的机制。通过这个机制，所有的 I/O 操作，底层API的调用都变成了异步的。但用户的 Javascript 代码是运行在主线程中的，如果这部分代码运行耗时很长，就会导致事件循环被阻塞。因为，它对于事件的处理，都是按照队列顺序的，所以如果其中的任何一个事务/事件本身没有完成，那么其他的回调、监听器、超时、nextTick() 都得不到运行的机会，被阻塞的事件循环没有机会去处理它们。这样下去，轻则效率降低，重则运行停滞。</p>
<p>比如我们常见的模板渲染，压缩，解压缩，加/解密等操作，都是 Node.js 的软肋，所以使用的时候要考虑到这方面。</p>
<h2 id="总结">总结</h2><ul>
<li>Node.js 通过 <code>libuv</code> 来处理与操作系统的交互，并且因此具备了异步、非阻塞、事件驱动的能力。</li>
<li>Node.js 实际上是 Javascript 执行线程的单线程，真正的的 I/O 操作，底层 API 调用都是通过多线程执行的。</li>
<li>CPU 密集型的任务是 Node.js 的软肋。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB1v9UnKXXXXXc5XXXXXXXXXXXX-900-500.png" alt="Node.js 探秘（一）- 初识单线程的 Node.js"></p>
<h2 id="前言">前言</h2]]>
    </summary>
    
      <category term="Node" scheme="http://taobaofed.org/tags/Node/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[淘宝首页兜底容灾方案]]></title>
    <link href="http://taobaofed.org/blog/2015/10/28/disaster-recovery-at-taobao-home-page/"/>
    <id>http://taobaofed.org/blog/2015/10/28/disaster-recovery-at-taobao-home-page/</id>
    <published>2015-10-28T02:23:53.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB1uf_3KXXXXXcLXVXXlzJZ8pXX-900-500.jpg" alt="淘宝首页兜底容灾方案"></p>
<p>淘宝首页是淘宝的一个大流量入口，平均每天的 PV 量达到一亿。而页面上的数据很多都是通过接口调用，不同的接口对应着不同的系统，每个系统的稳定性是不太一样的。</p>
<h3 id="一、兜底容灾的必要性">一、兜底容灾的必要性</h3><p>一个日均承载一亿流量的网页，会经常出现哪些问题呢？</p>
<ul>
<li>某个接口挂了，前端拿不到数据或者拿到的数据不够，页面展示就会出问题，出现空白或者某个模块直接天窗。</li>
<li>用户因为网络问题或者安装了某些插件，导致页面广告、接口请求挂掉，从而页面出现问题</li>
</ul>
<p>前者的概率不是很大，因为网页上的请求 QPS 都是预先评估过的，只要前端请求没有成倍激增，并且后端压力都在系统监控范围内，不会出太大的岔子。但是一旦出问题，页面上就有可能空白一大块，如果后端排查和处理问题不及时，很可能从小问题演变成故障，像淘宝首页这样的页面，还可能演变成公关问题，因为访问量实在太大，每分钟影响的人太多。</p>
<p>第二个问题也是比较严峻的，据统计，不管网站做的多简洁，总是会有千分之一的用户因为网络或者浏览器插件问题导致页面访问失败或者部分接口请求失败，一个 PV 一亿的网站，按照千分之一计算，一个接口每天会有 10w 左右的 PV 请求失败，而请求接口一多，页面上整体的请求失败量就很高了，这个数据会达到几百万。</p>
<h3 id="二、如何兜底，如何容灾">二、如何兜底，如何容灾</h3><p>兜底容灾的方案有很多，目的就是让请求失败而页面展示依然正常。下面说一说常用的几个方案：</p>
<p><strong>1. 再请求一次</strong></p>
<p>照顾到用户体验，同时也考虑到一个请求的正常发送、接受时间，我们把超时时间设置为 5s，超过 5s 或者请求的结果状态为 failed ，则重新请求一次。所以我们可以重新封装下 io 模块，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置请求次数</span></span><br><span class="line"><span class="keyword">var</span> tryTimes = <span class="number">2</span>;</span><br><span class="line">io(&#123;</span><br><span class="line">  url: url,</span><br><span class="line">  timeout: <span class="number">5000</span>,</span><br><span class="line">  dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">  <span class="comment">// try</span></span><br><span class="line">  tryTimes: tryTimes</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种处理方案对于提交订单、选中商品到购物车的页面比较合适，因为操作流是确定的，提交一次不成功，很自然的想到再提交一次，只是用户等待的不同阶段应该用不同的文案来提醒。而对于展示类的数据请求，不太适合多次失败尝试。所以首页未采用这种方案。</p>
<p><strong>2. 缓存每一次请求到本地</strong></p>
<p>现在的浏览器都支持本地储存（无论使用 userData 还是 localStorage），当每次请求到达用户浏览器的时候，把请求的数据缓存一份到本地储存，那么下次请求失败就可以使用上次的数据啦~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io(&#123;</span><br><span class="line">  url: url,</span><br><span class="line">  dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 缓存数据到本地</span></span><br><span class="line">    cache(DATAKEY, data);</span><br><span class="line">    show(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 请求失败，获取本地缓存数据</span></span><br><span class="line">    <span class="keyword">var</span> data = cache(DATAKEY);</span><br><span class="line">    show(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方式是比较常用的，每次请求成功都会缓存最新的数据。不过这里存在两个问题：</p>
<ul>
<li>如果用户第一次访问就失败了呢？要知道新用户是比较多的。</li>
<li>缓存的数据是否具有时效性，如果过期了呢？比如是一个推荐接口，推荐的商品用户已经购买过了，但是访问的时候接口挂掉，依然现实用户购买过的商品，这个逻辑是不太能接受的。</li>
</ul>
<p>当然，有总比没有好吧，就算是第一次访问，这个概率是相当低的，就算数据过期，但是依然是正确的链接，所以基本可以接受。</p>
<p><strong>3. 备用接口（硬兜底）</strong></p>
<p>会给自己的网页接口准备备用接口的网站，估计不会很多。而淘宝首页基本都用了。我们可以做一个包装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io(&#123;</span><br><span class="line">  url: url,</span><br><span class="line">  <span class="comment">// 备份接口</span></span><br><span class="line">  backUrl: backUrl</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一旦请求失败，进入备用数据接口请求备份数据。同样的，这里也存在一个问题：如果接口是个性化的，则每个用户访问这个接口拿到的数据都不一样，那么这个备份接口该如何推数据？如果备用接口的数据跟正常接口一样，那还不如直接去请求两次。</p>
<p>所以这里提到的备用接口，主要是数据的硬兜底，硬兜底的来源有两个：</p>
<ul>
<li>运营维护一份数据，推送到 CDN，每一份数据都有一个固定的地址</li>
<li>后端向 CDN push 一份通用数据。我们知道个性化都是使用 cookie 去识别用户的，对于没有浏览器记录的新用户就没有 cookie，此时会推一份通用的数据，这个通用的数据也可以作为接口的备份源。</li>
</ul>
<h3 id="三、兜底容错实践">三、兜底容错实践</h3><p>我们很容易得到如下的操作流程：</p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/29f3505c1dc13a36895ee512dd848984f9432615" alt="异步容错实践"></p>
<p>而这里存在的问题是：</p>
<ul>
<li>获取缓存数据后，不好对数据格式进行判断，一般来说，只有有效的数据才能存到本地储存中，而判断是否有效往往存在误差</li>
<li>兜底数据没有及时更新</li>
<li>程序只会报警，但是不会自动修复</li>
</ul>
<p>存在的隐患是：</p>
<ul>
<li>前端每次改版，如更换接口、更换人员，兜底数据没有及时更新</li>
<li>如果兜底数据也存在错误，则页面一定出现空白天窗</li>
</ul>
<p>所以对整个流程做了一些改进：</p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/f40f3c59aeada60c13e288c7791dfb81faaf7619" alt="异步容错改进"></p>
<p>数据经过统一平台输出，在输出之前，我们将数据推一份到 CDN 作为备份，产生另一个接口，一旦原始接口请求失败，则直接请求备份的接口，这个在规则对应和即时更新上可以做到很赞！那么基本的流程就是这样：</p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/1c4e211f77fac256961ab864c792d0a94ac5068d" alt="异步容错改进流程"></p>
<p>实际上淘宝首页在这个基础上还加了一层，那就是每个接口必须对应一个运营手填的数据，这个作为最后的硬兜底，而这个硬兜底也会被缓存到本地，整个流程就形成一个闭环。那么，剩下的工作就只有监控和警报了。</p>
<p>下面是一串伪代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = interfaceURL;</span><br><span class="line"><span class="keyword">var</span> backUrl = interfaceBackURL;</span><br><span class="line"><span class="keyword">var</span> hardBackUrl = hardDataURL;</span><br><span class="line"><span class="keyword">var</span> cacheTime = <span class="number">10</span>day;</span><br><span class="line"></span><br><span class="line">io(&#123;</span><br><span class="line">  url: url,</span><br><span class="line">  backurl: backUrl,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 缓存数据到本地</span></span><br><span class="line">    cache(DATAKEY, data, cacheTime);</span><br><span class="line">    show(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 请求失败，获取本地缓存数据</span></span><br><span class="line">    <span class="keyword">var</span> data = cache(DATAKEY);</span><br><span class="line">    <span class="keyword">if</span>(data) &#123;</span><br><span class="line">      Reporter.send(<span class="comment">/*WARN*/</span>);</span><br><span class="line">      show(data); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Reporter.send(<span class="comment">/*ERROR*/</span>);</span><br><span class="line">      _failed();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求硬兜底</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_failed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  io(&#123;</span><br><span class="line">    url: hadrBackUrl,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 缓存数据到本地</span></span><br><span class="line">      cache(DATAKEY, data, cacheTime);</span><br><span class="line">      show(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      Reporter.send(<span class="comment">/*SUPER_ERROR*/</span>);</span><br><span class="line">      show(data); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，我们在上面使用了缓存失效时间，考虑到数据的及时性，设置为 10 天。backUrl 是 url 的备份地址，hardBackUrl 是运营填写的备份数据，整个流程都在闭环之中，所以出问题的概率就大大降低了，即便是后端接口出错，我们也可以看着监控信息，放心的给后端开发 GG 打个电话，告知下等待修复，而不是急急忙忙，抓耳挠腮，担惊受怕天窗来了。</p>
<h3 id="小结">小结</h3><p>本文提供的都是伪代码，而这些伪代码的实现并不复杂，也没必要写成组件，主要是提供思路，如何处理大流量高并发下的异步数据接口的兜底容灾。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB1uf_3KXXXXXcLXVXXlzJZ8pXX-900-500.jpg" alt="淘宝首页兜底容灾方案"></p>
<p>淘宝首页是淘宝的一个大流量入口，平均每天的 PV 量达到一]]>
    </summary>
    
      <category term="兜底容灾" scheme="http://taobaofed.org/tags/%E5%85%9C%E5%BA%95%E5%AE%B9%E7%81%BE/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSTracker 之前端异常数据采集]]></title>
    <link href="http://taobaofed.org/blog/2015/10/28/jstracker-how-to-collect-data/"/>
    <id>http://taobaofed.org/blog/2015/10/28/jstracker-how-to-collect-data/</id>
    <published>2015-10-27T23:11:43.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms01.alicdn.com/tps/i1/TB1wsEtKXXXXXXTXXXXlzJZ8pXX-900-500.jpg" alt="JSTracker 之前端异常数据采集"></p>
<h2 id="JSTracker_-_淘宝前端监控平台">JSTracker - 淘宝前端监控平台</h2><p>基本上服务器端的代码都是处于 7x24 小时的实时监控状态的，一旦有任何异常对应的开发同学就马上收到报警，并且第一时间处理。 但是对于前端来说，往往是实际用户那里的脚本报错后才知道页面出现异常，这时候已经是故障了。</p>
<p>为了让前端也能和后端一样，需要将线上的 JavaScript 代码监控起来，当用户端浏览器出现异前端第一时间被通知到。于是便有了淘宝前端的监控平台：JSTracker。</p>
<h3 id="采集哪些数据">采集哪些数据</h3><p>在解决怎么采集之前，还需要解决采集哪些数据，哪些数据是有用的？</p>
<p>主要原则就是避开用户敏感字段，采集浏览器版本、操作系统版本、报错的 msg 信息等。</p>
<h3 id="JavaScript_异常的时候捕获异常">JavaScript 异常的时候捕获异常</h3><p>主动捕获异常方案主要是 onError 和 addEventListener，<br>onError 在 IE6 开始就支持了，所以 JSTracker 的主动采集是使用的 onError。</p>
<p>onError 可以采集到 file、line、col 等信息，但是实际情况中却大部分收集到的是 script error。<br><img src="http://gtms03.alicdn.com/tps/i3/TB15K6KKXXXXXXTaXXXbb5uUFXX-1166-360.png" alt="收集到的 script error"></p>
<p>原因是浏览器的同源性策略（CORS），在高级浏览器中如果浏览器捕获到了错误信息，如果 JS 文件所在的域名（如：g.alicdn.com）和当前的页面地址（如：www.taobao.com）是跨域的，那么浏览器会把 onError 中的 msg 替换为 script error，其余字段也会做替换。</p>
<p>webkit 的源代码：<br><img src="http://gtms04.alicdn.com/tps/i4/TB19rzGKXXXXXXAaXXX5JvL5XXX-966-459.png" alt="webkit 的源代码"></p>
<p>Script error 这个问题也是目前大家最诟病的一个问题：当报警发生之后，我们只知道有问题，但是很难知道哪里出了问题。</p>
<p>其实是有解决方案的：</p>
<ul>
<li><p>首先 JavaScript 请求的 http 返回头上需要加上一个 Access-Control-Allow-Origin 头。<br><img src="http://gtms01.alicdn.com/tps/i1/TB1cdz2KXXXXXXqXFXXusByLVXX-712-390.png" alt="Access-Control-Allow-Origin 头"></p>
</li>
<li><p>在引入 JavaScript 文件的时候需要在 script 标签上添加 crossorigin 属性，在加这个属性前请一定确保上一条已经完成，否则 JavaScript 文件不会执行！！！。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://somremotesite.example/script.js"</span> <span class="attribute">crossorigin</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个解决方式看起来完美，但是要做的改造实在是太多了，目前还是主动上报为主。</p>
<h3 id="主动上报异常">主动上报异常</h3><p>onError 的方案会采集到全面的浏览器报错，但是太全了，出了刚才的 script error 问题，还会采集到。</p>
<ul>
<li>ISP 在页面中注入的脚本报错（我们的前端质量很高的，但是被这些牛氓们一弄，啥质量都没了）。</li>
<li>插件问题（乱七八糟的插件也是一样的令人讨厌，注入奇怪的东西在页面中，引起报错）。</li>
</ul>
<p>为了让采集到的错误更有价值，需要暴露接口给让前端门自己在代码中上报异常（作为一名合格的代码工程师，一定要有抛异常的习惯呢）。</p>
<p>现在我们提供了自定义上报的接口，没错就是这么简单，你不用担心 JSTracker 脚本有没有加载，只要在你的代码中直接用就行了。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">window</span>.JSTracker2 = <span class="keyword">window</span>.JSTracker2 || [];</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    //your code</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    JSTracker2.push(&#123;</span><br><span class="line">      msg: <span class="string">"xx_api_failed"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己上报的错误对于定位也是很容易的：<br><img src="http://gtms02.alicdn.com/tps/i2/TB1ROPIKXXXXXauaXXX58beWpXX-1172-322.png" alt="自己上报的错误"></p>
<h3 id="一些细节问题">一些细节问题</h3><h4 id="在代码中使用_try_catch_是否对性能有影响">在代码中使用 try catch 是否对性能有影响</h4><p>try catch 对性能的影响微乎其微，但是一些用法会让性能受很大的影响， 参考这个实验：<a href="http://taobaofed.org/blog/2015/10/28/try-catch-runing-problem/">http://taobaofed.org/blog/2015/10/28/try-catch-runing-problem/</a></p>
<p>总结下来就是：在 try 语句块中不要定义太多的变量，最好是只写一个函数调用，避免 try 运行中变量拷贝造成的性能损耗。类似的不只是 try，定义 function 也是一样的。</p>
<h4 id="采集到的数据如何发出去">采集到的数据如何发出去</h4><p>JSTracker 的数据发送了非常大，这块都交给后端帮我们处理，采集部分只需要关注准确无误的把数据发送出去。</p>
<p>最初的简单的发送方案，直接用 GET 请求，将参数拼接在 URL 后面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'xxx'</span>;</span><br><span class="line"><span class="keyword">new</span> Image().src = url;</span><br></pre></td></tr></table></figure>
<p>后来发现这样发送有一定概率丢失数据,当浏览器回收内存的时候这个请求是发不出去的，所以要将这个变量 hold住：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> win = <span class="built_in">window</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="string">'jsFeImage_'</span> + _make_rnd(),</span><br><span class="line">  img = win[n] = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  win[n] = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">img.src = src;</span><br></pre></td></tr></table></figure>
<h4 id="随机数造成的数据丢失">随机数造成的数据丢失</h4><p>我们为了防止缓存，经常会用毫秒的时间作为随机数（如：+new Date()），但是在极端情况下可能1ms就会发出两条 log，这样第二条 log 就会丢失。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _make_rnd  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (+<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">'.r'</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="360浏览器识别">360浏览器识别</h4><p>为了能更好的统计这个浏览器，需要识别360SE、360EE。众所周知 3Q 大战之后360的 UA 就和 Chrome 的一样，所以我们要用一些特别的方法识别它们。目前为止能够识别的方案，这个方案会随时更新，适应360的变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> is360 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/UBrowser/i</span>.test(navigator.userAgent))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.scrollMaxX !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _track = <span class="string">'track'</span> <span class="keyword">in</span> <span class="built_in">document</span>.createElement(<span class="string">'track'</span>);</span><br><span class="line">    <span class="keyword">var</span> webstoreKeysLength = <span class="built_in">window</span>.chrome &amp;&amp; <span class="built_in">window</span>.chrome.webstore ? <span class="built_in">Object</span>.keys(<span class="built_in">window</span>.chrome.webstore).length : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.clientInformation &amp;&amp; <span class="built_in">window</span>.clientInformation.languages &amp;&amp; <span class="built_in">window</span>.clientInformation.languages.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_track) &#123;</span><br><span class="line">      <span class="keyword">return</span> webstoreKeysLength &gt; <span class="number">1</span> ? <span class="string">' QIHU 360 EE'</span> : <span class="string">' QIHU 360 SE'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms01.alicdn.com/tps/i1/TB1wsEtKXXXXXXTXXXXlzJZ8pXX-900-500.jpg" alt="JSTracker 之前端异常数据采集"></p>
<h2 id="JSTracker_-_淘宝前]]>
    </summary>
    
      <category term="JSTracker" scheme="http://taobaofed.org/tags/JSTracker/"/>
    
      <category term="监控" scheme="http://taobaofed.org/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="工具&amp;平台" scheme="http://taobaofed.org/categories/%E5%B7%A5%E5%85%B7-%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[try catch 对代码运行的性能影响]]></title>
    <link href="http://taobaofed.org/blog/2015/10/28/try-catch-runing-problem/"/>
    <id>http://taobaofed.org/blog/2015/10/28/try-catch-runing-problem/</id>
    <published>2015-10-27T23:09:56.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB14IUrKXXXXXblXXXXlzJZ8pXX-900-500.jpg" alt="try catch 对代码运行的性能影响"></p>
<h2 id="起因">起因</h2><p>要捕获 JavaScript 代码中的异常一般会采用 try catch，不过 try catch 的使用是否是对代码性能产生影响呢？答案是肯定有的，但是有多少不得而知。</p>
<p>淘宝前端线上脚本错误的捕获方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.JSTracker = <span class="built_in">window</span>.JSTracker || [];</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//your code</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  JSTracker.push(e);</span><br><span class="line">  <span class="keyword">throw</span> e; <span class="comment">//建议将错误再次抛出，避免测试无法发现异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计实验方式">设计实验方式</h2><p>简单的设计方案也就是对比实验。</p>
<p>空白组1：[无 try catch 的情况下对数据取模1千万次耗时]</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>1 无try catch的情况耗时<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">        !<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//无try catch的情况耗时</span></span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//耗时代码开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> p = i % <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//耗时代码结束</span></span><br><span class="line">            <span class="built_in">document</span>.write(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">        &#125;();</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>参照组2：[将耗时代码用 try 包围，内联耗时代码]</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>2 在 try 中内联代码的耗时情况<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">        !<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在 try 中内联代码的耗时情况</span></span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//耗时代码开始</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> p = i % <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//耗时代码结束</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">        &#125;();</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>参照组3：[将耗时代码用 try 包围，外联耗时代码]</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>3 在 try 中内联代码的耗时情况<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">        !<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//耗时代码开始</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> p = i % <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//耗时代码结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在 try 中内联代码的耗时情况</span></span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                run();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">        &#125;();</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>参照组4：[将耗时代码用 catch 包围，内联耗时代码]</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>4 在 catch 中内联代码的耗时情况<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">        !<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在 catch 中内联代码的耗时情况</span></span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                <span class="comment">//耗时代码开始</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> p = i % <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//耗时代码结束</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">        &#125;();</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>参照组5：[将耗时代码用 catch 包围，外联耗时代码]</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>5 在 catch 中内联代码的耗时情况<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">        !<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//耗时代码开始</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> p = i % <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//耗时代码结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在 catch 中内联代码的耗时情况</span></span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">        &#125;();</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="运行结果（只选取了_Chrome_作为示例）">运行结果（只选取了 Chrome 作为示例）</h2><table>
<thead>
<tr>
<th>-</th>
<th>不使用 try-catch</th>
<th>try 中耗时，内联代码</th>
<th>try 中耗时，外联代码</th>
<th>catch 中耗时，内联代码</th>
<th>catch 中耗时，外联代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrome44</td>
<td>98.2</td>
<td>1026.9</td>
<td>107.7</td>
<td>1028.5</td>
<td>105.9</td>
</tr>
</tbody>
</table>
<h2 id="给出总结">给出总结</h2><ul>
<li>使用 try catch 的使用无论是在 try 中的代码还是在 catch 中的代码性能消耗都是一样的。</li>
<li>需要注意的性能消耗在于 try catch 中不要直接塞进去太多的代码（声明太多的变量），最好是吧所有要执行的代码放在另一个 function 中，通过调用这个 function 来执行。</li>
</ul>
<p>针对第二点，可以查看 ECMA 中关于 try catch 的解释，在代码进入 try catch 的时候 js引擎会拷贝当前的词法环境，拷贝的其实就是当前 scope 下的所有的变量。</p>
<h2 id="建议">建议</h2><p>在使用 try catch 的时候尽量把 try catch 放在一个相对干净的 scope 中，同时在 try catch 语句中也尽量保证足够少的变量，最好通过函数调用方式来 try catch。</p>
<h2 id="试验中的现象解释">试验中的现象解释</h2><p>测试过程中还是发现了一个疑问, 以下两段代码在 Chrome 44 中运行出来的结果差距非常大，加了一句空的 try catch 之后平均为：850ms，加上之前为：140ms。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">//无 try catch 的情况耗时</span></span><br><span class="line">     <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//耗时代码开始</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;  i &lt; <span class="number">100000000</span>;  i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> p = i % <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//耗时代码结束</span></span><br><span class="line">     <span class="built_in">document</span>.write(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">     &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">//无 try catch 的情况耗时</span></span><br><span class="line">     <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//耗时代码开始</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;  i &lt; <span class="number">100000000</span>;  i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> p = i % <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//耗时代码结束</span></span><br><span class="line">     <span class="built_in">document</span>.write(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line"></span><br><span class="line"> &#125;();</span><br></pre></td></tr></table></figure>
<p>其实原因很简单<br>只要把代码改为这样 耗时就降下来了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         !<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="comment">//无 try catch 的情况耗时</span></span><br><span class="line">             <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//耗时代码开始</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;  i &lt; <span class="number">100000000</span>;  i++) &#123;</span><br><span class="line">                 <span class="keyword">var</span> p = i % <span class="number">2</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//耗时代码结束</span></span><br><span class="line">             <span class="built_in">document</span>.write(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">         &#125;();</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">         &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;();</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://yanhaijing.com/es5/#234" target="_blank" rel="external">http://yanhaijing.com/es5/#234</a></li>
<li><a href="https://code.google.com/p/v8/issues/detail?id=1065" target="_blank" rel="external">https://code.google.com/p/v8/issues/detail?id=1065</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms04.alicdn.com/tps/i4/TB14IUrKXXXXXblXXXXlzJZ8pXX-900-500.jpg" alt="try catch 对代码运行的性能影响"></p>
<h2 id="起因">起因</h2><p>]]>
    </summary>
    
      <category term="performance" scheme="http://taobaofed.org/tags/performance/"/>
    
      <category term="web" scheme="http://taobaofed.org/tags/web/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Are u ok？---记一次H5项目的安卓适配]]></title>
    <link href="http://taobaofed.org/blog/2015/10/28/auto-layout-in-h5-project/"/>
    <id>http://taobaofed.org/blog/2015/10/28/auto-layout-in-h5-project/</id>
    <published>2015-10-27T22:18:10.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB15IMmKXXXXXXzXpXX2AXZ8pXX-900-500.png" alt="Are u ok？---记一次H5项目的安卓适配"></p>
<h3 id="Are_u_ok_?">Are u ok ?</h3><p>当雷布斯难以和台下的印度粉丝语言沟通的时候，他不由自主地向台下的米粉呐喊Are u ok 抒发他不能讲中文却无比激动的情绪。</p>
<p>当我看到那台老款安卓机上的H5页面的时候，我也想对它说 Are u ok? </p>
<p>我不是要卖给印度人手机，而是因为在这些低版本的安卓机面前我也常常词穷技穷。</p>
<h3 id="问题背景">问题背景</h3><p>无线化风生水起呀，最近做的无线项目里有几个H5的网页，在大部分手机上表现得很正常，但是适配测试阶段测试提的一个问题：在中兴U930上，页面整体布局错乱。</p>
<p>眼看离提交手淘测试时间点越来越近了，PDPM测试问我能不能提交手淘啊，我只能说遗憾地说，”有一款手机上适配有问题，还要看看。”</p>
<p>因为这个适配问题让我很难办，不能审查DOM，定位只能靠猜和试。我说还要看看，真的是只能看看。</p>
<p>我问顺堂MDS(淘宝的无线调试平台)能不能调，顺堂居然羞涩地低下了头：安卓4.4以下的确实不行呢。因为devtool….（广告费你懂的）</p>
<p>PC端有坏孩子IE，到了移动端还有安卓系统碎片化的问题。世界太不和谐了。</p>
<h3 id="有图有真相">有图有真相</h3><p>一般情况下，H5页面显得很好很正常<br><img src="http://img2.tbcdn.cn/L1/461/1/9f4117125688c27b1a06ecdafe8019f37ac6ceb4" alt="图1"></p>
<p>而在中兴U930上是这样的。</p>
<p><img src="http://img3.tbcdn.cn/L1/461/1/7aa911ea32a8256f2bd91b4be7f5f01cc6b9058f" alt="图2"></p>
<p>丑的我都不好意思贴出来</p>
<h3 id="问题分析">问题分析</h3><p>问题还是得解决的，没办法，只好从整个无线工程渲染和适配的过程开始想一遍了。</p>
<p>首先判断是浮动布局造成的影响，毕竟浮动布局容易引起的问题，于是将同行的元素全都改成成inline-block，重新布局后满心期待push，一看，问题依旧，该怎样还是怎样。</p>
<p>窗外天气不是很好，有点雾霾，要不把你这手机扔出去算了。-。-</p>
<p>从截图上看，原因可能是某个元素占据了整行，也有可能是文档流节点总宽度超出了容器宽度。</p>
<p>既然其他机型上宽度都是正常的，为什么唯独这款的宽度不正常呢？这个问题始终绕不过。因为到目前为止，始终还在样式布层面考虑。既然还是无法定位，说明仅仅考虑CSS可能无法找到问题根源或是线索了。</p>
<p>应该从现在项目依赖的平台和框架整个过一遍页面的适配和渲染过程。</p>
<h3 id="设备兼容">设备兼容</h3><p>我们的移动设备分辨率各式各样，视觉稿却是一个固定的大小。无线应用需要铺满整个屏幕，也就是自适应，和PC的不一样。那么我们的如何做到适应这么多分辨率呢？</p>
<p>还好有kimi(淘宝前端团队针对移动端H5开发提供的整体解决方案)。</p>
<p>无线kimi项目依赖于m-base, m-base通过设定根元素的rem，即通过HTML根元素相对长度单位来定义一个相对的基准单位，为什么说是相对的呢？因为这个基准单位的值在不同分辨率下是不同的。所以可能从m-base上能找到线索。</p>
<p>那么m-base的这个HTML根元素的font-size到底是如何计算出来的呢。</p>
<p>m-base从1.0.0开始，前端对rem的基准处理统一约定为：viewport/10，也等价于vw单位，后续的rem规范基准都以屏宽十分之一为准，和手淘首页新标准、天猫均保持一致。</p>
<p>也就是说，我们规定了（篇幅有限，这里只贴出部分规范）<br>1rem = viewport / 10;<br>750的设计稿，1rem = 75px; 1px = 1/75 rem; 200px = 200 / 75 = 2.666666667rem;<br>640的设计稿，1rem = 64px; 1px = 1/64 rem; 200px = 200 / 64 = 3.125rem;</p>
<h3 id="这个标题叫什么好呢">这个标题叫什么好呢</h3><p>分析到这就有点眉目了，可能是rem基准单位值设置大了;也可能是这设备对rem的计算不准确。第二点不在我们控制范围内。所以只考虑第一点：先查一下这个机型现在的1rem值和viewport宽度值，这个设备上只有祭出alert大法了。</p>
<p><strong> 打印meta 信息，打印viewport, document, device宽度信息</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> metas = <span class="built_in">window</span>.parent.<span class="built_in">document</span>.getElementsByTagName(<span class="string">"meta"</span>)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; metas.length; i++) &#123;</span><br><span class="line">    alert(metas[i].getAttribute(<span class="string">"name"</span>))</span><br><span class="line">    alert(metas[i].getAttribute(<span class="string">"content"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(<span class="pi">/ZTE U930_TD/</span>.test(navigator.userAgent));</span><br><span class="line">alert(<span class="built_in">document</span>.documentElement.clientWidth);</span><br><span class="line">alert(<span class="built_in">document</span>.body.clientWidth);</span><br><span class="line">alert(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">alert(<span class="built_in">window</span>.pageXOffset);</span><br><span class="line">alert(<span class="built_in">window</span>.outerWidth);</span><br><span class="line">alert(screen.width);</span><br><span class="line">alert(<span class="built_in">window</span>.rem);</span><br></pre></td></tr></table></figure>
<p><strong>打印结果</strong></p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>document.documentElement.clientWidth</td>
<td>360</td>
</tr>
<tr>
<td>document.body.clientWidth</td>
<td>360</td>
</tr>
<tr>
<td>window.innerWidth</td>
<td>360</td>
</tr>
<tr>
<td>window.pageXOffset</td>
<td>360</td>
</tr>
<tr>
<td>window.outerWidth</td>
<td>540</td>
</tr>
<tr>
<td>screen.width</td>
<td>540</td>
</tr>
<tr>
<td>window.rem</td>
<td>40.67</td>
</tr>
</tbody>
</table>
<p>可以看到viewport宽度是360px，与该机型屏幕分辨率960x540相差了很大，这不科学啊~<br><a href="http://detail.zol.com.cn/326/325040/param.shtml" target="_blank" rel="external">该机型的屏幕参数见这里</a></p>
<p>可以看到1rem=40.67px，这和预计的54px也不一样，而且也不是36px（viewport的1/10）。</p>
<p>奇怪，难道是该机型有推出过增强版或是乞丐版？而我手上的是乞丐版？于是去工信部网站查该设备。<a href="http://www.tenaa.com.cn/WSFW/LicenceShow.aspx?code=jpokusu3tlOFxUU4Lw2sNhOXuAZbYVdDfASF7DKgVYi6efm5qzmAAbUin3DJS6Mc" target="_blank" rel="external">工信部链接在这里</a><br>似乎没有其他版本，但是意外看到了设备证书到期时间—本月10号就要到期了，哦呵呵。</p>
<h3 id="定位问题">定位问题</h3><p>宽度我们改变不了，那么从基准rem着手。<br>为什么rem=40.67，按照设备信息算应该是54，按照实际的viewport算应该是36。</p>
<p>想不通，看m-base源码是怎么算的吧。<br>搜索git代码库找到m-base，运气不错，很快就搜到了相关代码</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/5e1aeab961e13b61d4ccf56a09ca46295794bab4" alt="图3"></p>
<p>可以看到m-base对该机型做了特殊处理<br>40.678/1.13正好就是36，看来确实只有360px。</p>
<p>既然viewport就是360px，那么把rem设置为36px应该是正确的呀。<br>于是在项目代码里hack一段</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.<span class="comment">rem = document.documentElement.clientWidth / 10;</span></span><br><span class="line">var fontEl = document.createElement('style');</span><br><span class="line">fontEl.innerHTML = 'html: &#123;font-size:' + window.<span class="comment">rem + 'px !important&#125;';</span></span><br><span class="line">document.documentElement.firstElementChild.appendChild(fontEl);</span><br></pre></td></tr></table></figure>
<p>满心期待push后一看，没啥变化。打印window.rem，还是40.67。<br>应该是因为很多脚本在执行，无法保证在这一段代码在m-base后执行来获得更高的样式优先级，异步之殇啊。</p>
<p>那就粗暴一点直接设置标签属性<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.<span class="comment">rem = document.documentElement.clientWidth / 10;</span></span><br><span class="line">$('html').attr('style', 'font-size: ' + window.<span class="comment">rem + 'px !important');</span></span><br></pre></td></tr></table></figure></p>
<p>刷新页面果然生效了<br><img src="http://img2.tbcdn.cn/L1/461/1/f07ed845db192f0f10e69dd1348c2d2fcc507c3f" alt="图4"></p>
<p>可以看到右边有一大片空白。<br>看来设备的真实viewport值大于360小于406.7，而rem大于36小于40.67。</p>
<p>到这里应该就算完全定位问题了。窗外雾霾似乎少了点，这手机也算捡回了条命。</p>
<h3 id="解决问题">解决问题</h3><p>接下来就是是体力活了：采用折半搜索确定rem的准确值，算一次改一次刷新一次，尝试38.335太小39.5太小…试到大概40.06看上去差不多了</p>
<p>效果如图<br><img src="http://img3.tbcdn.cn/L1/461/1/1747b910882969e04c7cb75d818d8433d4b4f67e" alt="screenshot"></p>
<p>已经很接近屏幕边缘了，问题修复到这其实可以算是fixed了</p>
<p>屏幕右边还是有一丝丝白边，对处女座不够友好。</p>
<p>但饭点都过了，手指刷的都不听话了。</p>
<p>可是我还想算的更精确。</p>
<blockquote>
<p>只要是重复的事情，肯定可以被程序取代。<br>                                                                             — 我</p>
</blockquote>
<p>所以跑个任务吧</p>
<p>流程很简单</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/e1eb474fa4ffe0c59f69ab2449c4a33bfc7d8e19" alt="流程图"></p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var adaptTheDevice = function (<span class="built_in">start</span><span class="comment">Rem) &#123;</span></span><br><span class="line">    window.<span class="comment">rem = startRem || window.rem;</span></span><br><span class="line">    var _ss = $('#xiangsi-dianpu .sim-shop').first().<span class="built_in">find</span>('.itemsinshop a');</span><br><span class="line">    var flag = true;</span><br><span class="line">    var stepping = <span class="number">0</span>.<span class="number">0001</span>;</span><br><span class="line">    var time_in = new <span class="built_in">Date</span>().getTime();</span><br><span class="line">    while (flag) &#123;</span><br><span class="line">        <span class="flow">for</span> (var i = <span class="number">1</span>; i &lt; _ss.length; ++i) &#123;</span><br><span class="line">            <span class="flow">if</span> (_ss[i].offsetTop &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                alert('error')</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="flow">if</span> (_ss[i - <span class="number">1</span>].offsetTop != _ss[i].offsetTop) &#123;</span><br><span class="line">                alert(window.<span class="comment">rem - stepping);</span></span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(window.<span class="comment">rem);</span></span><br><span class="line">        window.<span class="comment">rem = window.rem + stepping;</span></span><br><span class="line">        $('html').attr('style', 'font-size: ' + window.<span class="comment">rem + 'px !important');</span></span><br><span class="line">    &#125;</span><br><span class="line">    alert("used <span class="built_in">time</span>: " + (new <span class="built_in">Date</span>().getTime() - time_in) + " ms");</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/6b948eedcc320cdc6751d2cc80d56e35f605e583" alt="screenshot"></p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/60552e09f2786f09ae51a4382f15904dfbb796e8" alt="screenshot"></p>
<p>好吧，只用了20s就跑下来了，适配的值定为40.076，以后再有丧心病狂的安卓4.0来袭就不用重复踩这个坑了，重跑一下这个任务就行了。</p>
<p>最后给m-base提个issue。</p>
<h3 id="后记">后记</h3><p>解决这个问题一共花了等效时间约2人日，实际时间大约要一周。<br>据统计2014年每天都有约三部智能机上市，如果适配的单位是机器的话，现在市面上近共约四千部智能机每个型号都能测一遍吗？做得到吗？</p>
<p>更合理的适配单位应当是操作系统版本—-以操作系统版本为适配标准的量尺，同时兼顾个别经典机型。</p>
<p>毕竟雷布斯有勇气讲英文了，我们为什么不向前走呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://gtms02.alicdn.com/tps/i2/TB15IMmKXXXXXXzXpXX2AXZ8pXX-900-500.png" alt="Are u ok？---记一次H5项目的安卓适配"></p>
<h3 id="Are_u_ok_?]]>
    </summary>
    
      <category term="H5" scheme="http://taobaofed.org/tags/H5/"/>
    
      <category term="安卓" scheme="http://taobaofed.org/tags/%E5%AE%89%E5%8D%93/"/>
    
      <category term="无线" scheme="http://taobaofed.org/tags/%E6%97%A0%E7%BA%BF/"/>
    
      <category term="适配" scheme="http://taobaofed.org/tags/%E9%80%82%E9%85%8D/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[致想用 Node.js 的你]]></title>
    <link href="http://taobaofed.org/blog/2015/10/27/enter-the-door-of-nodejs/"/>
    <id>http://taobaofed.org/blog/2015/10/27/enter-the-door-of-nodejs/</id>
    <published>2015-10-27T07:20:12.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/i2/TB1Q5gmKXXXXXXCXpXXlzJZ8pXX-900-500.jpg" alt="致想用 Node.js 的你"></p>
<p>Node.js，09 年这个集成了 Google V8 JavaScript 引擎和一个底层 I/O API 的项目，如今项目无数，大企业也纷纷尝试。</p>
<p>Node.js 有如得到了金陵才子一般，忽然间就在大街小巷中风靡开来，诱人的滋味感觉谁都想咬一口，虽然其他语言的酸葡萄理论开始蔓延，但是依旧没有影响到它的推广和发展。在强大的 PHP 和稳定的 Java 之中，慢慢的发芽并占有了一席之地。</p>
<p>虽说一开始 0.6 版本的 Node.js 像玩具，只能简单做些小工具，但是并不妨碍各种尝试。当初 lua 语言大肆流行，多亏了 wow 的插件体系，暴雪当作粘合剂，而程序员玩家纷纷效仿，一度一夜之间冒出许多 lua 开发的文章。而 Node.js 也似乎是一夜之间，多出了各种新手教程，当然也无非就是安装和敲敲 <code>hello world</code>，但是不管怎么说，软文多了之后，眼球已经被深深的吸引了。</p>
<p>虽然 python 也可以一句话创建 Server，但是 JS 却是头一回，除了在 windows 上编译费劲外，似乎一切都那么完美。这也是第一次 JS 立足于不同的土地，通过事件驱动和非阻塞 IO，创造了一片新的大陆。</p>
<p>除了社区的活跃，npm 包管理的问世和内置集成也功不可没。Java 之所以流行，Ant 和 Maven 的工程化套件必不可少，而后者的 JAR 包管理中心化更是将 Java 的共享和社区化推进到了一个新的高度，而 npm 正是 Node.js 版本的仓库，大海中无数种类的鱼，总有你想要的，程序员们总能找到想要的东西，而且正是由于 JS 代码的可见性，借鉴和更新变的非常容易。</p>
<p>当然 npm 也有它本身的缺陷，模块包的代码质量良莠不齐，不过高质量的代码库总能获得最多的下载量，也算是一个弥补措施了。</p>
<p>一个服务器并不能满足前端们的好奇心，模仿是天生的，所以之后开始使用 Node.js 来编写各种工具，最直接的就是打包脚本，妥妥的从 YUI Compressor 中解放了出来，后来各种轻语言开始迁移工具，纷纷开始支持，比如 Less 和 Sass。自此开始，Node.js 走上了一条人人都会一点，人人都来咬一口的局面。</p>
<p>1.0 之前，算是大跃进时期，每个版本都有着非常鲜明的特色和功能。虽然前段时间 io.js 的事情闹得沸沸扬扬，各路人马甚至开始考虑站队的事情，当然最后还是合并了，算是不错的结尾，Node.js 4.0 的时代也算是开始，应该会开始稳健的进步了。</p>
<p>全栈工程师的 title 也自此开始冒泡，其实一直都有，以前这些从前写到后的人，大多是小公司加班出来的。</p>
<p>发现写了这么多，大多写了些历史和演变，还是回到其本身。Node.js 本身就是个万精油，什么都能干，但是并不一定拿它干最好，有些事情还是要找对应的语言，比如复杂度很高的计算，那就不应该是它干的。存在既是理由，您拿一把斧头砍树固然好，挖土就不行，所以用之前评估和衡量还是非常之重要。而 Node.js 更擅长处理并发连接，单进程的 JS 语言没有什么死锁的压力，而自由的写法更加使得代码变的有吸引力。</p>
<p>除了 npm 算是官方提供的包管理之外，似乎没什么官方提供的支持了，这也是 Node.js 的弱项吧，配套比不过其他语言，要啥啥没有，好在社区强大，现在算是成熟许多，debug、profiler 等一应俱全。</p>
<p>想用 Node.js 的你，必须是一个有耐心、细心的人才能驾驭，可能你会在一整天排查一个内存溢出问题，也可能花上大半天搞定一个莫名其妙的依赖错误，这些都是以前我实实在在碰到过的。不过好在现在 Node.js 的报错规范了许多，大多还是能够一眼就看出问题。</p>
<p>当然，最后希望你好好的用 Node.js，用好它，那么它就会更好。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/i2/TB1Q5gmKXXXXXXCXpXXlzJZ8pXX-900-500.jpg" alt="致想用 Node.js 的你"></p>
<p>Node.js，09 年这个集成了 Google V8]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node地下铁]]></title>
    <link href="http://taobaofed.org/blog/2015/10/27/node-subway/"/>
    <id>http://taobaofed.org/blog/2015/10/27/node-subway/</id>
    <published>2015-10-27T06:00:23.000Z</published>
    <updated>2015-11-13T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tps/TB13N.dKXXXXXaTXFXXXXXXXXXX-900-500.png" alt="Node地下铁"></p>
<p>没有一种语言是不朽的，Node.js 也是，但冷静的思辨无价。</p>
<p>这里是由淘宝前端团队（FED）发起的 Node.js 爱好者的地下聚集社区，产出我们在 Node.js 实践中的原创思考和片面观点。</p>
<p>欢迎关注。</p>
<p>BTW，我们在招人~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tps/TB13N.dKXXXXXaTXFXXXXXXXXXX-900-500.png" alt="Node地下铁"></p>
<p>没有一种语言是不朽的，Node.js 也是，但冷静的思辨无价。</p>
<]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="团队生活" scheme="http://taobaofed.org/categories/%E5%9B%A2%E9%98%9F%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
